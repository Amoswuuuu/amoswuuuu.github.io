{"meta":{"title":"Amos'Blog","subtitle":"恒者行远，思者常新。","description":"恒者行远，思者常新。","author":"Amos","url":"https://blog.amoswu.top","root":"/"},"pages":[{"title":"友情链接","date":"2009-04-22T19:24:48.000Z","updated":"2021-01-12T13:51:56.000Z","comments":true,"path":"friends/index.html","permalink":"https://blog.amoswu.top/friends/index.html","excerpt":"","text":""},{"title":"Page","date":"2013-12-26T14:52:56.000Z","updated":"2022-01-29T23:32:22.000Z","comments":true,"path":"page/index.html","permalink":"https://blog.amoswu.top/page/index.html","excerpt":"","text":"This is a page test."},{"title":"about","date":"2026-01-30T09:15:15.000Z","updated":"2026-01-30T09:35:58.000Z","comments":true,"path":"about/index.html","permalink":"https://blog.amoswu.top/about/index.html","excerpt":"","text":"往前走，别回头。 关于此博客 本博客创建于2018年10月10日，主要分享一些开发技术、经验，读书笔记、影评和一些日常随笔。"}],"posts":[{"title":"体面「告别」的修行——评《莲花楼》","slug":"体面「告别」的修行——评《莲花楼》","date":"2026-01-30T04:00:00.000Z","updated":"2026-02-03T08:53:08.000Z","comments":true,"path":"419d.html","link":"","permalink":"https://blog.amoswu.top/419d.html","excerpt":"","text":"初看《莲花楼》，最直观的感受是它并不急于展示大开大合的英雄气概，而是用一种近乎散文的节奏，带人走进一位江湖人的余生。这部剧最成功的地方在于它捕捉到某种“后武侠”时代的通透，并将其与我们当下的现实生活紧紧系在一起。剧中的李相夷曾是立于巅峰的神话，像极了年轻时怀揣宏大理想的我们，而故事的重心却放在了坠落后的李莲花身上。这种从巅峰回归平凡的自洽，让整部剧透出一种难得的烟火气，也隐喻了人生的常态：如何面对失去，以及如何与平凡的自己握手言和。 这种关于“失去”的基调，不仅体现在李莲花一人身上，更蔓延在剧中众生相的“爱而不得”里。乔婉娩对李相夷的爱，是错位时空中的追悔与遗憾；她爱的是那个光芒万丈的英雄，却在漫长的等待中消耗了所有的勇气，最终即便相见也只能相忘于江湖。角丽谯对笛飞声的爱，则是另一种极端的偏执与占有；她试图用权力和控制去换取一个武痴的回眸，却终究在疯狂的自我感动中走向毁灭。还有展云飞那份从未说出口的守护，以及单孤刀因执念不得转为滔天恨意的扭曲。这些感情交织在一起，构成了一个真实而残缺的江湖：每个人都在求索，却也都在学着告别。 在叙事结构上，这部剧的严谨程度令人惊喜。它没有让案情沦为散乱的背景，而是通过剥笋式的手法，将所有看似无关的奇闻异事自然地串联在一起。每一个案件背后都藏着人性的贪婪与执念，这些执念最终汇聚成十年前那场阴谋的收束与回响。这种环环相扣的逻辑闭环，让剧作的衔接显得扎实且有后劲。随着剧情推进，观众会发现李莲花破的每一个案子，其实都是在剪断自己与过去的最后一根红线。片尾曲《人世太匆忙》写的不是“豪情”，而是“来不及”的人世。“人世太匆忙，等不及地老天荒。来日又方长，还个神仙愿望。” 最打动人心的是李莲花对待生命的态度。在那个所有人都在执着于变强、复仇或占有的江湖里，他却在逆流而行，一步步走向彻底地放下。他原谅了昔日的恋人，放过了曾经的对手，甚至释怀了师兄的背叛。结局那句“去去重去去，来时是来时”，是他对世间的终极告别。而当歌词唱到“聚散得失一眨眼，情话微微共婵娟，只盼能相念不相欠。”那种无可奈何却又必须体面转身的心境，便被更安静、更准确地托住了。它告诉我们，最高级的英雄主义不是战胜对手或占有爱人，而是看清生活的真相后，选择以一种体面的姿态抽身离去。 整部剧拍得克制且温润，它让我们看到，即便生命已经破碎，即便爱而不得是人生常态，人依然可以活得有尊严、有温度。这不仅是台词和歌词里的江湖，更是一剂针对现代人精神内耗的良药。 图 / Nano Banana Pro文/ Amos &amp; GPT 5.2","categories":[{"name":"影视评论","slug":"影视评论","permalink":"https://blog.amoswu.top/categories/%E5%BD%B1%E8%A7%86%E8%AF%84%E8%AE%BA/"}],"tags":[{"name":"莲花楼","slug":"莲花楼","permalink":"https://blog.amoswu.top/tags/%E8%8E%B2%E8%8A%B1%E6%A5%BC/"},{"name":"剧评","slug":"剧评","permalink":"https://blog.amoswu.top/tags/%E5%89%A7%E8%AF%84/"}]},{"title":"简明 Book Searcher 使用教程","slug":"简明 Book Searcher 使用教程","date":"2023-02-24T16:00:00.000Z","updated":"2026-01-30T07:08:16.000Z","comments":true,"path":"83e2.html","link":"","permalink":"https://blog.amoswu.top/83e2.html","excerpt":"","text":"自建 Book Searcher 地址： https://book.amoswu.cn Index version : 0.9.0 Book Searcher 简介Book Searcher 是 Z-library 的一个民间项目之一。这个项目是在 Z-library 被封之后诞生的，它的前身是 Anna’s Archive**，国内网友将 Anna’s Archive 数据库做成索引，通过搜索 IPFS ID 继而获得相应结果的下载链接。起初这个项目的名叫 **zLib Searcher，后来改名成了 Book Searcher。 项目开源地址： https://github.com/book-searcher-org/book-searcher IPFS 简介IPFS的全称是 InterPlanetary File System ，即星际文件系统。它是一个点对点（P2P）的网络超媒体协议。它的目标是成为更快、更安全、更开放的下一代互联网，当然这不是它的终极目标，终极目标是取代现在的 HTTP ，创建一个完全去中心化的网络。 官网：https://ipfs.io Book Searcher 使用方法1. 打开以下任意网址 https://book.amoswu.cn https://zlib.awesc.com https://zlib.knat.network 2. 点击右上角⚙️设置图标，输入 IPFS 网关地址，点击保存直接复制下列地址即可 123456https://cloudflare-ipfs.comhttps://dweb.linkhttps://ipfs.iohttps://dw.oho.imhttps://gateway.pinata.cloudhttps://ipfs.best-practice.se ps: 如果哪天上述地址都不可用了，你还可以使用下面的 IPFS 网关检查工具来替代，尽量选择延迟较低的。 https://ipfs.github.io/public-gateway-checker https://ipfs-checker.1kbtool.com 3. 任意搜索你想搜的书籍其他搜索引擎推荐https://bk.hallowlib.org https://clibrary.cn","categories":[{"name":"教程","slug":"教程","permalink":"https://blog.amoswu.top/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"教程","slug":"教程","permalink":"https://blog.amoswu.top/tags/%E6%95%99%E7%A8%8B/"},{"name":"2023","slug":"2023","permalink":"https://blog.amoswu.top/tags/2023/"}]},{"title":"免费正版图书期刊阅读方法分享","slug":"免费正版图书期刊阅读方法分享","date":"2022-06-23T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"73a3.html","link":"","permalink":"https://blog.amoswu.top/73a3.html","excerpt":"","text":"万般皆下品，唯有读书高。 近年来，随着移动互联网的兴起，越来越多的信息通过互联网来到我们面前。随着信息量的指数级增长，越来越多人想要跳出信息茧房，主动出击，获取自己想要的信息。阅读出版发行物，是其中一个比较靠谱的信息来源。但是，大多数出版物都是需要付费的产品，对于想随时翻看，尽可能多地触及更多种类的读者来说是个不小的门槛。今天，我就给大家介绍一种免费可行的方法，让大家在手机APP、小程序、微信以及电脑网页等多种客户端随时随地阅读自己想看的出版物。 首先，我们先来认识一下这个方法的载体——博看书苑。 博看书苑简介博看书苑数字阅读系统主要收录涉及党政、时事、军事、管理、财经、文摘、文学、艺术、情感、家庭、健康、时尚、娱乐、科技、教育、教学等40多类4000多种主流畅销人文期刊。超过4000多家期刊社达成正式合作，基本涵盖全部人文畅销类期刊，是现今最大最全的人文畅销期刊数据库，全新上线的图书版块包括30000多册近五年出版的图书，报纸版块包括超过200种网络主流报纸。博看在全国拥有1000多万的读者，以符合读者阅读习惯、以在线翻页的原貌版为基础，同时提供文本版等多种阅读形式。支持PC端，APP端、微信端和触摸大屏阅读系统[1]。 看完介绍，我们继续了解一下它的多个客户端访问入口。 多端访问入口PC：请直接访问 http://zq5.bookan.com.cn/#/login APP：下载地址 https://download.bookan.com.cn 微信小程序： 微信搜一搜 “博看书苑” 接下来，就是具体的操作步骤 操作步骤 以PC为例，打开上述链接； 注册账号后，输入机构授权码（见下文）； 使用这个账号，开始你的阅读之旅吧~ ▲ 以华中科技大学图书馆为例 【重要】授权码获取各省市图书馆授权码浙江图书馆：zjlib 上海图书馆：shlib 四川图书馆：sclib 安微图书馆：ahst 山东图书馆：sdlib 山西图书馆：sxlib 甘肃图书馆：gzlib 新疆图书馆：xjlib 武汉图书馆：whlib 随州图书馆：szlib 镇江图书馆：zjst 梧州图书馆：wzlib 兴义市图书馆：xyslib 各高校图书馆授权码 获取方法： 搜索引擎搜索关键词 博看 site: edu.cn 武汉大学图书馆：whu 吉林大学图书馆：jlulib 四川大学图书馆：scu 河南大学图书馆：hndx 南华大学图书馆：usc 沈阳大学图书馆：sydxlib 广西大学图书馆：gxulib 华中科技大学图书馆：lib 中国药科大学图书馆：cpuedu 中国科学技术大学图书馆：zkdlib 参考链接[1] 中国药科大学图书馆 - 博看书苑数字阅读系统","categories":[{"name":"教程","slug":"教程","permalink":"https://blog.amoswu.top/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"教程","slug":"教程","permalink":"https://blog.amoswu.top/tags/%E6%95%99%E7%A8%8B/"},{"name":"2022","slug":"2022","permalink":"https://blog.amoswu.top/tags/2022/"}]},{"title":"Qt程序中优雅的日志方案","slug":"Qt程序中优雅的日志方案","date":"2021-03-30T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"f624.html","link":"","permalink":"https://blog.amoswu.top/f624.html","excerpt":"","text":"一个完整的软件（系统）都要有一套优雅的日志方案。 发现问题在使用Qt开发软件（系统）过程中，出于多种目的，开发者难免需要记录程序运行过程中的一些状态信息，也就是我们常说的日志。Qt 中的日志模块（qInstallMessageHandler）配置繁杂，对于日志设计新手来说很不友好，虽然官方给出了Demo，但其繁杂程度依旧不减。 使用Golang、Python等语言开发过程序的开发者，应该都听说过 Loguru，它是在流行语言领域优雅日志方案的佼佼者。在Qt C++ 开发中有没有Loguru或者和它媲美的日志方案呢？ 问题调研在寻找好的日志记录方案前，有必要先了解清楚两个问题，我们为什么要记录日志？日志记录的要素有哪些？ 为什么要记录日志？1.开发调试目的是开发期调试程序使用，这种日志量比较大，且没有什么实质性的意义，只应该出现在开发期，而不应该在项目上线之后输出。 2.记录用户行为这种类型的日志，记录用户的操作行为，用于大数据分析，比如监控、风控、推荐等等。这种日志，一般是给其他团队分析使用，而且可能是多个团队，因此一般会有一定的格式要求，开发者应该按照这个格式来记录，便于其他团队的使用。当然，要记录哪些行为、操作，一般也是约定好的，因此，开发者主要是执行的角色。 3.记录程序运行情况记录程序的运行状况，特别是非预期的行为、异常情况，这种日志，主要是给开发、维护人员使用。什么时候记录，记录什么内容，完全取决于开发人员，开发者具有高度自主性。 4.记录系统、机器状况比如网络请求、系统CPU、内存、IO使用情况等等，这种日志主要是给运维人员使用，生成各种更直观的展现形式，配合预警系统，在系统出问题时及时预警。 日志记录的要素有哪些？每条日志都可以被当作一个事件（event），记录了该事件发生时各种信息，这些信息大概有以下几类。 1.时间这个时间通常是指事件发生的时间，并不是日志被打印的时间。它通常用标准时间或时间戳的形式输出。 2.位置这个位置一般有模块位置、文件位置、函数位置、代码所在行等等，根据敏感程度的不同，我们输出位置的级别也不同。 3.级别级别也就是日志的重要程度，主要用于不同的环境（测试、生产）下，打印不同级别的日志；不同级别的日志产生不同级别的监控报警。 4.内容内容也就是我们要展示给日志阅读者和使用者的信息，要简明扼要地描述这个模块、函数、文件等发生了什么事情。 5.唯一标识在大型集群系统、分布式系统中，为了快速定位日志输出点，我们需要唯一标识作为日志的主体。 6.格式化将上述的信息按照固定的格式打印出来，或输出到文件中，就是日志的格式化。这样做的目的不仅仅是方便阅读，还能方便后期编写日志解析程序。 7.其他根据程序、业务等特点，还可以在日志中记录（包括但不限于）：错误次数、处理进度、IP地址等等。 解决问题明白了上述内容，我们可以在遵循 使用框架或模块、不能出错、避免敏感信息、合理归档分类等原则的情况下，选择一个合适的框架来达到我们的目的。 Easylogging++如同 Loguru 一样，在 Qt C++ 中也可以有很优雅的日志方案，它就是集简单、轻量、高效、可配置等优点于一身的 **Easylogging++**。 虽然也有 C++ 版本的 Loguru ，但它的功能显然对 Qt 的支持不是很友好。于是我们选用了通用性较强的 Easylogging++ 来达到我们的目的。 入门知识日志等级常用的日志等级，由高到低，依次为 Error 、 Debug 、 Warning 、 Info 。 使用方式1LOG(日志等级) &lt;&lt; “日志内容”; 支持的 Qt 变量类型 * * * * * * QString QByteArray QLatin QList QVector QQueue QSet QPair QMap QMultiMap QHash QMultiHash QLinkedList QStack QChar q[u]int[64] 使用教程1）下载或克隆 Easylogging++ 仓库源码Github地址： https://github.com/amrayn/easyloggingpp 2） 原生 C++ 方式使用 将 src 文件夹下的 easylogging++.cc 和 easylogging++.h拷贝到要应用的项目目录； 初始化并输出一条日志 123456789101112// *.cpp// 导入头文件并初始化#include &quot;easylogging++.h&quot;INITIALIZE_EASYLOGGINGPP// 输出日志int main(int argc, const char* argv[]) &#123; LOG(INFO) &lt;&lt; &quot;This is a log generated by Easylogging++.&quot;;&#125; 注意事项 所有要输出的变量类型必须为标准 C++ 格式 初始化必须在 *.cpp文件中进行 3）Qt 调用方式 将 src 文件夹下的 easylogging++.cc 和 easylogging++.h拷贝到要应用的项目目录； 配置 *.pro 文件 12345678910// *.pro// 写入配置DEFINES += ELPP_QT_LOGGING \\ ELPP_FEATURE_ALL \\ ELPP_STL_LOGGING \\ ELPP_STRICT_SIZE_CHECK ELPP_UNICODE \\ ELPP_MULTI_LOGGER_SUPPORT \\ ELPP_THREAD_SAFE 初始化并输出一条日志 12345678910111213141516171819202122232425262728293031// *.cpp// 导入头文件并初始化#include &quot;easylogging++.h&quot;INITIALIZE_EASYLOGGINGPP#include &quot;logdemo.h&quot;#include &quot;ui_logdemo.h&quot;LogDemo::LogDemo(QWidget *parent) : QWidget(parent), ui(new Ui::LogDemo)&#123; ui-&gt;setupUi(this); InitLogger();&#125;LogDemo::~LogDemo()&#123; delete ui;&#125;/** 日志初始化 * @brief LogDemo::InitLogger */void LogDemo::InitLogger()&#123; QString s = &quot;This is a log generated by Easylogging++.&quot;; LOG(INFO) &lt;&lt; s;&#125; 注意事项 *.pro必须加入相应配置 所有要输出的变量类型可以为 受支持的Qt格式或标准 C++ 格式 初始化必须在 *.cpp文件中进行 更多拓展 独立配置文件 自定义 Logger 多线程 导出成动态链接库 … 参考链接[1] 知乎专栏 - 记录日志有哪些好的技巧？ [2] 静觅 - Python 中更优雅的日志记录方案 loguru [3] Github - Easyloggingpp","categories":[{"name":"随笔","slug":"随笔","permalink":"https://blog.amoswu.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"2021","slug":"2021","permalink":"https://blog.amoswu.top/tags/2021/"},{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"随笔","slug":"随笔","permalink":"https://blog.amoswu.top/tags/%E9%9A%8F%E7%AC%94/"},{"name":"Qt","slug":"Qt","permalink":"https://blog.amoswu.top/tags/Qt/"}]},{"title":"Qt程序中优雅的打包方案","slug":"Qt程序中优雅的打包方案","date":"2021-03-30T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"3ed5.html","link":"","permalink":"https://blog.amoswu.top/3ed5.html","excerpt":"","text":"Qt程序打包，没有想象中那么复杂。 发现问题在使用 Qt C++ 发布生成 *.exe 时，需要复制大量 dll 动态链接库文件，这一点相信每一个 Qt 开发者都经历过。除了手动复制，能不能有一种更优雅的解决方案呢？ 问题调研在当前的主流语言中，打包方式可谓是大道至简。使用 C++ 时，你可以通过 Visual Studio 自带的打包插件完成打包；使用 Python 时，你可以借助 PyInstaller 这样的打包工具执行命令完成打包； 使用 Golang 时，你可以借助它自带的打包工具执行命令完成打包… Qt 官方为了解决这一问题，早就在 Qt 安装时内置一个一键打包程序 —— wideployqt.exe。 解决方案windeployqt.exe 使用教程1. 准备文件 一个 release 模式下编译好的 exe； 其他非系统库； exe 启动时读取的目录或文件等。 准备好上述文件后，将它们拷贝至一个新建的文件夹中，文件夹路径和命名不能包含中文。 2. 启动 Qt 对应编译器的控制台程序我使用的 MinGW 5.3.0 ， 故选择图中这个控制台程序。 ​ 3.在控制台打开编译好的 exe 所在路径 4. 输入打包命令开始打包打开对应路径后，输入下方的打包命令，即可开始打包。 1windeployqt [exe文件名] 稍等片刻，打开文件夹你会看到，所有的 dll 库已经拷贝完成了，我们可以打开 exe 试一试打包是否成功。 参考链接[1] 新浪博客 - Qt之打包发布（NSIS详解） [2] CSDN - 教你使用windeployqt工具来进行Qt的打包发布","categories":[{"name":"随笔","slug":"随笔","permalink":"https://blog.amoswu.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"2021","slug":"2021","permalink":"https://blog.amoswu.top/tags/2021/"},{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"随笔","slug":"随笔","permalink":"https://blog.amoswu.top/tags/%E9%9A%8F%E7%AC%94/"},{"name":"Qt","slug":"Qt","permalink":"https://blog.amoswu.top/tags/Qt/"}]},{"title":"从零开始搭建NTP服务","slug":"从零开始搭建NTP服务","date":"2021-03-23T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"2956.html","link":"","permalink":"https://blog.amoswu.top/2956.html","excerpt":"","text":"0x01. NTP 简介NTP(Network Time Protocol) 的全称是 网络时间协议 ，它是用来使计算机时间同步化的一种协议，它可以使计算机对其服务器或时钟源做同步化，它可以提供高精准度的时间校正（LAN上与标准时间差小于1ms，WAN上是几十毫秒）。 0x02. Windows 时间服务简介从Windows2000开始，所有的Microsoft Windows 操作系统都内置了 Windows时间服务（即W32Time），它具有将计算机时钟与NTP服务器同步的能力。 Windows 10 和 Windows Server 2016 中的时间同步已大幅改善。 在合理的操作条件下，可将系统配置为维持 1ms（毫秒）的精度或更高的精度（相对于 UTC）。 ——From Microsoft 0x03. Win NTP 服务器详细搭建步骤Step 1. 打开 Windows 注册表按下 Windows键 + R 或 打开 运行，输入 regedit后点击确定。 Step 2. 找到指定路径 -1依次展开至 Config 路径，或直接在路径输入框复制下方路径后回车跳转。 1计算机\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\Config Step 3. 修改指定的值 -1在右侧找到 AnnounceFlags，双击，将它的 数值数据 改为 5，单击确定。 Step 4.找到指定路径 -2依次展开至 NtpServer 路径，或直接在路径输入框复制下方路径后回车跳转。 1计算机\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\NtpServer Step 5. 修改指定的值 -2在右侧找到 Enabled，双击，将它的 数值数据 改为 1，单击确定。 Step 6. 启动 W32Time 服务按下 Windows键 + R 或 打开 运行，输入 services.msc 后点击确定； 找到 Windows Time 服务项，双击，将它的 启动类型 设置为 自动，单击确定。 Step 7. 重启 W32Time 服务按下 Windows键 + X + A 或 以管理员身份运行 cmd.exe ，依次输入 net stop w32time 和 net start w32time 后点击确定； 按下 Windows键 + R 或 打开 运行，输入 cmd 后点击确定； 在弹出的窗口中，输入 netstat -an ，回车，在输出的文本中可以看到 UDP 0.0.0.0:123 *:* ，说明 NTP 服务搭建成功。 0x04. Windows 和 Linux 下 NTP 对时服务的使用WindowsStep 1.打开 Internet时间 设置在任务栏右下角单击时间，继续单击 日期和时间设置 ； 在弹出的窗口中，点击 添加不同时区的时钟 ； 在弹出的窗口中，单击 Internet时间 选项卡，单击 更改设置 按钮； 在弹出的窗口中，输入搭建好NTP服务的主机地址，单击 立即更新 。 Ubuntu在终端输入命令 sudo ntpdate 192.168.10.123 ，输入密码，出现类似 step time server 192.168.10.123 offset -1231.354535 sec 字样即表示成功。 参考链接： [1] Microsoft - Windows 时间服务 (W32Time) [2] Github - microsoft/W32Time","categories":[{"name":"教程","slug":"教程","permalink":"https://blog.amoswu.top/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"2021","slug":"2021","permalink":"https://blog.amoswu.top/tags/2021/"},{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"教程","slug":"教程","permalink":"https://blog.amoswu.top/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"10分钟搞定装机入门知识","slug":"10分钟搞定装机入门知识","date":"2021-03-10T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"e182.html","link":"","permalink":"https://blog.amoswu.top/e182.html","excerpt":"","text":"引言随着疫情防控进入了常态化，越来越多的人需要把家里的“老古董”电脑进行一轮升级换代。有的是适应居家办公的需求，有的是适应居家上网课的需求，还有的是适应居家娱乐的需求······总而言之，这些需求的实现都需要一定的装机知识储备。 本文将站在电脑小白的角度，向你科普一些装机必备的入门知识，将尽量避免使用专业术语和行业黑话，只为助你提高装机效率。 为了尽量保证此次分享的严谨性，我将主要讨论Windows平台的机器，Linux、MacOS等暂时不在此次的讨论范围。我将从主要部件中央处理器、内存、硬盘、独立显卡、主板、电源、显示器、声卡等方面一一展开。 一、中央处理器 CPU中央处理器（CPU）是一台电脑的核心部件。很大程度上，一台电脑的好用与否和CPU有着不可分割的关系。目前主流的Windows平台的CPU厂商有两个，分别是Intel和AMD。 Intel 目前 Intel 在售的系列主要有两个，一个是消费级（家用级）的 Core（酷睿）系列，另一个是专业级（服务器级） Xeon（至强）系列。但从同一代产品来说， Xeon 的性能远高于 Core ，至强之于酷睿，好比高铁之于火车。当然，价格也是与性能成正比的。 我们继续聊消费级的 Core 系列，它共有四条产品线，分别是 入门级的i3、主流级的i5、高端级的i7和旗舰级的i9，它们的主频通常情况下是数字越大，主频越高的。主频，我们可以简单理解为计算机执行运算的速度。简单说，处理器代数等条件相同的情况下，数字越大越好。 在售卖方面，CPU 的包装方式有盒装和散装两种。这两种方式对于CPU本身没有差别，差别主要集中在质保和有无散热器等方面。也就是说，同等选择下，有钱你可以买个放心，选择盒装CPU，否则就选散装CPU。选散装朋友也不需要担心会买到假货、山寨货，毕竟CPU的生产制造工艺十分复杂，仿制成本非常高。 常见的CPU后缀，我整理了一张图，大家可以按图索骥。 AMD AMD 家的 CPU 目前在售的热门系列是 Ryzen（锐龙）系列，它也对标 Intel 的产品线设置了 入门级的R3、主流级的R5、高端级的R7、旗舰级的R9以及线程撕裂者。 AMD 处理器的市场份额虽不如 Intel，但是AMD在消费级CPU领域的产品还是很有诚意的。 AMD CPU 在选择时尽量选择有 X 后缀版。 另外，还有一个小技巧分享给你，购买 CPU 前可以在 百度贴吧搜索ID 秋刀鱼半藏，或搜索 AMD吧、笔记本吧、Intel吧，查看最新的**CPU天梯图**。 二、内存 Memory 内存的全称叫“随机存取器”，英文表达是 “Random Access Memory”，也简称为 RAM。顾名思义， 内存会在断电后丢失数据。内存在电脑的硬件系统中扮演的是桥梁的作用，执行程序时它会暂存程序，CPU 取用数据时它也会暂存数据。它的存在是为了提高电脑硬件系统的整体运行效率，打个比方就是，我们在吃饭时都会从锅中盛到碗里吃，这里的锅就是硬盘，碗就是内存。 内存的好坏会直接决定电脑的运行速度，因此选择合适的内存也是装机的关键。区分内存的好坏，广义上讲，有三大指标：内存代数、内存频率、内存容量。 目前主流的内存代数有 DDR3 和 DDR4，不久的将来要普及的 DDR5 也将是更好的选择。其他指标相同的情况下，代数越高越好。目前市场上多数都是标准电压内存（也叫“标压内存”），当然受到低压CPU的影响，市场上也还存在一些低压内存，它们的显著标志是带“L”，如DDR3L，这类内存如果新装机的话是极度不推荐的。 内存频率是衡量内存速度的直观指标。其他指标相同的情况下，频率越高越好。 内存容量也是我们常说的内存大小，容量越大，系统会越流畅，多开程序也就不会卡顿。这就好比碗越大，盛下的菜和饭种类越多一样。值得注意的是，内存容量在32位操作系统中会受到限制，原因是32位操作系统支持的最大内存容量是3.9G，所以推荐大家使用 64 位操作系统。 三、硬盘 Disk 硬盘是计算机最主要的存储设备。硬盘（港台称之为硬碟，英文名：Hard Disk Drive， 简称HDD 全名温彻斯特式硬盘）由一个或者多个铝制或者玻璃制的碟片组成。这些碟片外覆盖有铁磁性材料。 ——来自 百度百科 目前市面上常见的硬盘有两类，分别是 机械硬盘(HDD) 、固态硬盘(SSD) 。它们各有优缺点，下面我们展开来讲一讲。 先来说一说机械硬盘，它是诞生最早的一种硬盘，一直被沿用至今。故它的英文名字沿用了硬盘的英文名字 Hard Disk Drive ，简称 HDD。 机械硬盘通常由一个或者多个铝制或者玻璃制成的磁性碟片，磁头，转轴，控制电机，磁头控制器，数据转换器，接口和缓存等几个部分组成。 ——来自 百度百科 机械硬盘的优点主要有容量大、价格低等，缺点显而易见噪音大、散热差、存取速度慢、重量大等等。 机械硬盘有五个特征指标，硬盘尺寸通常受限于硬盘所搭载的平台类型。 容量，也就是我们常说的存储空间大小。值得注意的是，现在大多数厂商为了方便计数，将原来的 1TB = 1024GB 默认成了 1TB = 1000GB。 接口类型是受限于电脑主板的一个指标，现在消费级主板多为 SATA 3.0 接口，服务器级多为 SAS 接口。 转速，即硬盘碟片的转动速度，单位通常是 转/分钟 (rpm)，也是机械硬盘的一大指标，这个指标与噪音成正比，在一定程度上也与性能成正比。 固态硬盘是用固态电子存储芯片阵列制成的硬盘，从字面意思理解，我们可以知道它的存储介质是固态颗粒。 固态驱动器（Solid State Disk或Solid State Drive，简称SSD），俗称固态硬盘。因为台湾英语里把固体电容称为Solid而得名。SSD由控制单元和存储单元（FLASH芯片、DRAM芯片）组成。 —— 来自 百度百科 固态硬盘有很多优点，常见的有存取速度快、噪音小、方便携带等等，最显而易见的缺点是价格相较于机械硬盘要高一些。 固态硬盘广义上的主要指标有两个，分别是存储容量和接口类型。细分还有主控类型、缓存颗粒类型、闪存芯片类型等等不在我们此次的讨论范围。 目前常见的固态硬盘接口有6类，按带宽（存取速度）排序 SATA &lt;= mSATA &lt;= M.2-SATA &lt;= U.2 &lt;= PCIE &lt;= NVMe 。 综合上述两种类型来说，固态硬盘有着无可比拟的读写速度，在固态硬盘上运行的操作系统流畅度远高于在机械硬盘上运行的操作系统，但机械硬盘具有文件可恢复的良好特性。 机械硬盘数据的可恢复性是由它的内部结构决定的。通常情况下，我们在执行删除操作时，机械硬盘中的数据只是被标记为删除状态，这样既是出于提高速度考虑，也是为了避免数据被误删考虑。也就是说，我们在使用机械硬盘时，只要删过的磁盘没有被重新覆盖，那么数据在理论上都是可恢复的。这也就好比是盛过一种饭的碗，总能通过化学分析等手段，找到这种饭的化学成分一样。只要你不将碗刷干净（完全擦除硬盘）或用这个碗盛别的饭（重新存入别的数据），总有办法分析出它的成分（找回你的数据） 。 当然，机械硬盘由于内部是机械结构，在磁头与磁盘反复接触的过程中难免会出现磨损，一旦出现磨损扇区，会出现物理坏道（好比光盘上的划痕），从而导致存取时间变长，甚至数据丢失。这就是之前的电脑时间一长会出现卡顿、蓝屏、死机等现象的原因。 为了同时兼具机械硬盘和固态硬盘的优点，我们在装机时常常选用混合硬盘的方案，也就是 固态硬盘 + 机械硬盘的方案。固态硬盘安装操作系统、必要的软件、游戏等等，机械硬盘用于存储其他数据、资料。 四、独立显卡 Display Card 显卡（Video card、Display card、Graphics card、Video adapter）是个人计算机基础的组成部分之一，将计算机系统需要的显示信息进行转换驱动显示器，并向显示器提供逐行或隔行扫描信号，控制显示器的正确显示，是连接显示器和个人计算机主板的重要组件，是“人机”的重要设备之一，其内置的并行计算能力现阶段也用于深度学习等运算。 显卡大致可以分为两类，一类是核心显卡或集成显卡（简称“核显”或“集显”），它们都与CPU集成在了一起，主要功能就是输出显示信号；另一类是独立显卡（简称“独显”），它们都独立于CPU之外，主要功能除了输出显示信号外，还能单独进行运算和3D渲染等等。 核显的性能我们就不介绍了，毕竟它是随着CPU迭代而迭代的。 我们重点来说一下独显，独显按用途分类也有两大类，一类是给绘图和3D渲染设计的专业显卡；另一类是为游戏娱乐而设计的娱乐显卡，也叫消费级显卡。 一张显卡由GPU、风扇、电容等部件组成，其核心部件是GPU（显示核心），是显卡的心脏，相当于CPU在电脑中的作用。现在的GPU生产公司只有两家：NVIDIA和AMD，这两家公司在生产出一块GPU之后会对其进行命名，比如 GTX960、GTX970、GTX1080Ti等，再交付给下游的显卡制造商（比如影驰，七彩虹）去组装成显卡，这类显卡被称之为“非公版显卡”，在出售时会在“显卡核心型号”前加上自己厂商的名称作为前缀，用于和其他厂商进行区分。 目前的独显品牌市场可谓是“二分天下”，一边是以英伟达(NVIDA)为首的N卡阵营，另一边是以AMD为首的A卡阵营。我们从两大品牌的角度展开说一说。 英伟达显卡的产品线比较直观，这也让大众更容易接受它的产品。一般来说，N卡有五个重要指标， GeForce / Quadro 区别显卡用途，普通家用推荐 GeForce； GT / GTX / RTX 区别显卡级别 ，普通家用GTX 和 RTX 都可以； 10 / 20 / 30 代表显卡代数； 代数后面紧跟着的是中低高端的区别以及是否为增强版的标志； 最后是显存的大小。 由于AMD的显卡产品线比较复杂，如果简单分享的话，我建议你购买 RX系列，并参考显卡天梯图与同性能的N卡进行比较。 显卡天梯图，可以百度贴吧——显卡吧搜索ID “秋刀鱼半藏”查看。 五、主板 Motherboard 主板也是电脑的重要组成部分，它为CPU、内存、硬盘、显卡、键盘、鼠标、显示器等部件提供了一个安装平台，让这些部件联系在一起。因为要与CPU配对，所以主板也分为Intel主板和AMD主板。同时由于不同代CPU针脚的不同，选购主板时还要选择与之配对的某系主板。比如6系7系对应LGA 1155针脚的2代3代CPU，8系对应LGA 1150针脚4代5代CPU，100系和200系对应LGA 1151针脚6代7代CPU，300系对应就8代CPU。 高端主板和低端主板的差距在于做工用料，BIOS设计，功能性（超频）和拓展性（更多接口），但即使是最低端的主板基本该有的接口都会有，几乎不会出现低端主板没有显卡槽的情况。 主板属于有功能性但没性能的组件，主板的高端低端并不会对CPU性能产生影响，也不会对显卡性能产生影响。所以主板不像CPU，GPU那样有性能天梯图。选购主板时可根据自己的预算，可以选择像华硕，技嘉，微星这样的一线大公司，也可以选择其他二线公司做的主板。如果非得加一个区别的话，或许大厂有预算更新BIOS系统能算一个吧。 可以选择H系这样的入门主板，也可以选择B系这样的高性价比主板，只要主板本身质量过关，能适配上，接口够用，不需要超频，任何一款主板都行。考虑空间和散热可以选择大板，不考虑可以选择小板。高端主板和低端主板我们可以用高端轿车和普通轿车来类比。 六、 电源、显示器等电源是一台电脑的供电中心。台式机的电源一般在机箱内部，呈方盒状，一端有多个电线出口。笔记本的电源由电池和充电器两部分组成，电池的用料差别不大，但充电器随着充电技术的发展一直在迭代，从最初的“板砖”型笨重的充电器，逐渐过渡到了现在的 Type-C接口的氮化镓便携充电器。 台式机电源的选配一般是把电脑内部的各组件额定功耗值相加，再留有一部分冗余功率后确定的。原则上不要让电脑的实际最大使用功率超过电源额定功率的70% 显示器的选择是一个比较大的课题，今天就简单科普一些主流参数，大家可以作为参考。说到显示器，无非有尺寸、面板类型、分辨率、屏幕色域、响应时间、刷新率等参数，一般情况下，IPS面板，分辨率1080P以上，72%NTSC色域以上 / 85sRGB色域以上，响应时间小于等于6ms，刷新率60Hz以上的显示器几乎可以覆盖80%以上的使用需求。 除了电源和显示器，还有其他特殊需求的组件，如独立声卡、无线网卡等等，鉴于篇幅有限，这一次就不再一一讨论了。 七、一点忠告配置电脑存在“边际效应”，从低端升级到中端带来的效益是非常明显的，但如果从中端升级到高端带来的效益就会逐渐变小，这时你需要花很大的价钱才能提升少量的性能； 配置电脑也存在“木桶效应”，一台电脑就是一个复杂的硬件系统，它的性能是所有硬件共同决定的，如果某一硬件的性能特别低，势必会影响其他硬件的发挥。 以上，就是装机那些事儿的所有内容，如果你读完还有这方面的疑问，欢迎留在下方的评论区，我们一起讨论~ 参考链接： 1.博客 - 装机不求人，10 分钟电脑配置挑选速成攻略 2.Intel - 11th Generation Intel® Core™ i7 Processors 3.知乎 - 2021 CPU Intel、AMD选购推荐 笔记本（怎么选，性能怎么区分，快速入门）*一月更新 4.知乎 - 硬盘有哪些分类？分别有什么作用","categories":[{"name":"科普","slug":"科普","permalink":"https://blog.amoswu.top/categories/%E7%A7%91%E6%99%AE/"}],"tags":[{"name":"2021","slug":"2021","permalink":"https://blog.amoswu.top/tags/2021/"},{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"随笔","slug":"随笔","permalink":"https://blog.amoswu.top/tags/%E9%9A%8F%E7%AC%94/"},{"name":"科普","slug":"科普","permalink":"https://blog.amoswu.top/tags/%E7%A7%91%E6%99%AE/"}]},{"title":"Golang 环境配置小记","slug":"Golang 环境配置小记","date":"2021-03-08T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"53c2.html","link":"","permalink":"https://blog.amoswu.top/53c2.html","excerpt":"","text":"Go 编程语言是一个开源项目，它使程序员更具生产力。 Go 语言具有很强的表达能力，它简洁、清晰而高效。得益于其并发机制，用它编写的程序能够非常有效地利用多核与联网的计算机，其新颖的类型系统则使程序结构变得灵活而模块化。 Go 代码编译成机器码不仅非常迅速，还具有方便的垃圾收集机制和强大的运行时反射机制。 它是一个快速的、静态类型的编译型语言，感觉却像动态类型的解释型语言。 —— From Golang Blog 0x00. 安装环境12OS - Windows 10 Home x64 20H2Mem - 16GB 0x01.下载&amp;安装1. 下载源国内源 https://studygolang.com/dl 国际源 http://docs.studygolang.com/doc/install 2. 安装 下载完成后，双击 .msi安装包，安装到自己想要的路径； 在 cmd 中输入 go version，输出当前 golang 版本则安装成功。 0x02. 环境配置1. 环境变量配置 新建 GoPath目录，在此目录下新建三个文件夹 bin pkg src； 新建系统环境变量 GOBIN GOPATH GOROOT ，它们对应的路径分别是： GoPath目录下的bin文件夹 GoPath路径 Go安装路径； 添加 系统环境变量下 Path 的值为 %GOROOT%bin 重启，或管理员权限打开两个CMD，一个输入 set PATH=C:，另一个输入 echo %PATH%，在输出的路径中可以看到刚才的四个路径； 在 cmd 中输入 go env ，对应红框位置路径为刚刚设置的即可。 2. 配置镜像源在 cmd 中输入， go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/ 3. 配置 GoLand 安装后，打开GoLand并选择你的项目目录(或者是一个空目录，即将写代码的目录)， 依次点击file -&gt; setting -&gt; Go，点击GOROOT,选择你的 GoLand 位置所在，如下图 点击 GOPATH ，选择你的项目目录，如下图 在刚才创建的src目录下新建一个文件夹，可以是项目的名称，然后创建一个名为main.go的文件，代码如下 这里发生了一个小插曲，运行代码后发现编译器找不到包。 原因分析：编译器没有去GOPATH下找包。 gomod 和 gopath 两个包管理方案，并且相互不兼容，在 gopath 查找包，按照 goroot 和多 gopath 目录下 src/xxx 依次查找。在 gomod 下查找包，解析 go.mod 文件查找包，mod 包名就是包的前缀，里面的目录就后续路径了。在 gomod 模式下，查找包就不会去 gopath 查找，只是 gomod 包缓存在 gopath/pkg/mod 里面。 ——From CSDN 解决方案： 设置GO111MODULE为off即可。 1go env -w GO111MODULE=off 运行成功，配置结束~ ✌","categories":[{"name":"笔记","slug":"笔记","permalink":"https://blog.amoswu.top/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"2021","slug":"2021","permalink":"https://blog.amoswu.top/tags/2021/"},{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.amoswu.top/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Golang","slug":"Golang","permalink":"https://blog.amoswu.top/tags/Golang/"}]},{"title":"Markdown 从零开始","slug":"Markdown从零开始","date":"2021-03-03T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"c456.html","link":"","permalink":"https://blog.amoswu.top/c456.html","excerpt":"","text":"Markdown 是一种轻量级的「标记语言」，它的优点很多，自2004年被 John Gruber 发明以来，它已经发展成了世界上最受欢迎的标记语言之一。它也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，所以它的学习成本极低。 认识 Markdown正如前言所说，Markdown 是一种标记语言。所谓标记语言，字面意思可以理解为把我们写下的文字标记成统一的样式。说人话就是，它可以让使用者不用关注排版、样式、各种设置等繁琐操作，让使用者真正专注于书写。 既然是一种语言，它就会有特定的编辑器（专业术语也叫IDE）。Markdown 编辑器发展到现在已经不再是单一系统或单一形式的存在了。从 Windows 、Linux 再到 MacOS，从 Web、桌面客户端到手机 APP ，到处都有 Markdown 的身影，可以说是随时随地 Markdown。 学习 Markdown 的理由当你可以通过按下界面中的按钮来设置文本格式时，为什么还要使用 Markdown 来书写呢？大家目前公认的使用 Markdown 而不是 word 类编辑器的原因有： Markdown 无处不在。StackOverflow、CSDN、掘金、简书、GitBook、有道云笔记、V2EX、光谷社区、微信公众号等。主流的代码托管平台，如 GitHub、GitLab、BitBucket、Coding、Gitee 等等，都支持 Markdown 语法，很多开源项目的 README、开发文档、帮助文档、Wiki 等都用 Markdown 写作。大型互联网公司的内部文档管理系统，如阿里语雀、字节跳动飞书文档等等，都是使用 Markdown 作为书写载体进而达到知识的统一管理； Markdown 是纯文本可移植的。几乎可以使用任何应用程序打开包含 Markdown 格式的文本文件。如果你不喜欢当前使用的 Markdown 编辑器了，则可以将 Markdown 文件导入任意一个你喜欢的 Markdown 编辑器中； Markdown 是独立于平台的。你可以在运行任何操作系统的任何设备上创建 Markdown 格式的文本，无论是 PC 、移动 APP 甚至 Web 网页 ； Markdown 能适应未来的变化。即使你正在使用的编辑器将来会在某个时刻不能使用了，你仍然可以使用文本编辑器读取 Markdown 格式的文本。当涉及需要无限期保存的书籍、大学论文和其他里程碑式的文件时，这是一个重要的考虑因素； ······ 简单说，我个人认为使用 Markdown 写作的理由有五个： 简单易学——学习成本低，结合可视化编辑器十分钟就能上手； 专注写作——可以让我只关心于写作内容； 轻松导出——方便导出其他的文档格式； 格式多样——导出格式多种多样111，如 PDF、HTML、Word、EPUB等等； 方便管理——不必纠结于文档格式和保存形式，方便统一管理。 Markdown 的原理在使用 Markdown 格式书写时，文本内容存储在带有 .md 或 .markdown 扩展名的纯文本文件中。那然后呢？你的 Markdown 格式的文件如何转换为 HTML 或可打印的文档呢？ 简单来说，你需要一个能够处理 Markdown 文件的 Markdown 应用程序。有许多应用程序可供选择，从简单的脚本到类似于 Microsoft Word 的桌面应用程序。尽管它们在视觉上有所不同，但所有应用程序都执行相同的操作。像 在线 Markdown 编辑器 一样，它们都是将 Markdown 格式的文本转换为 HTML，以便可以在 Web 浏览器中显示。 Markdown 应用程序使用一种称为 Markdown 处理器（也通常称为“解析器”或“实现”）的东西将获取到的 Markdown 格式的文本输出为 HTML 格式。此时，可以在 Web 浏览器中查看你的文档，或者将其与样式表组合并打印。你可以在下图看到此过程的直观表示。 注意： Markdown 应用程序和处理器是两个单独的组件。为了简洁起见，在下图中，我将它们组合为一个元素（即 “Markdown应用程序”）。 Markdown 编辑器推荐对于一下编辑器，直接搜索引擎搜索安装即可。 Windows 平台 Typora Vditor Vs Code Atom Vim Sublime Text Notepad++ Linux 平台 Typora Vditor UberWriter GNU Emacs Atom Vim MacOS | iOS Mou iA Writer Ulysses Writer Pro Typora Web 在线使用 印象笔记 有道云笔记 语雀 StackEdit Dillinger Android 麻雀记 纯纯写作 言叶 Markdrop 十分钟入门 说明： 教程验证环境—— 操作系统（OS） - Windows10 Home 20H2 x64 编辑器（IDE） - Typora v0.9.96 教程全文遵循 Markdown GFM 语法规范，如果和其他规范有差别，请以 Github 官方发布的规范为准。 以下为源代码模式写作教程，如果你认为此种方式学习仍然比较困难，我推荐你使用 Typora 这类编辑器，可以图形化操作，直接右击鼠标点击你想要写的格式即可。 标题 标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。 # 一级标题 ## 二级标题 ### 三级标题 以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。 列表 熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加 1. 2. 3. 符号要和文字之间加上一个字符的空格。 引用 如果你需要引用一小段别处的句子，那么就要用引用的格式。 &gt; 例如这样 只需要在文本前加入 &gt; 这种尖括号（大于号）即可 图片与链接 插入链接与插入图片的语法很像，区别在一个 !号 插入图片的地址需要图床，这里推荐 PicGo + Github / 七牛云的形式，生成URL地址即可。 如果是内网，只需将图片和 Markdown 文件放到同一级目录后插入图片即可。 粗体与斜体Markdown 的粗体和斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。 例如：这里是粗体 这里是斜体 表格表格是我觉得 Markdown 比较累人的地方，例子如下： 12345678910111213| Tables | Are | Cool | | ------------- |:-------------:| -----:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | 这种语法生成的表格如下： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码框 如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown 下实现也非常简单，只需要用两个 `` 把中间的代码包裹起来，如 code。编辑代码过程中，使用 tab 键即可缩进。 分割线分割线的语法只需要另起一行，连续输入三个星号 *** 即可。 好了，看到这里你就可以安心使用 Markdown 简单书写你想写的一切东西了。不过，我还要提醒你的是，这只是其中最简单的部分，如果你想了解更多，欢迎查询相关资料进行进阶学习。 *部分图片来源于网络 参考内容： [1] 少数派 - 认识与入门 Markdown [2] 链滴- Markdown 使用指南 - 基础语法 [3] Daring Fireball-Daring Fireball: Markdown [4] Github - GitHub Flavored Markdown Spec","categories":[{"name":"教程","slug":"教程","permalink":"https://blog.amoswu.top/categories/%E6%95%99%E7%A8%8B/"},{"name":"笔记","slug":"教程/笔记","permalink":"https://blog.amoswu.top/categories/%E6%95%99%E7%A8%8B/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"2021","slug":"2021","permalink":"https://blog.amoswu.top/tags/2021/"},{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.amoswu.top/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Markdown","slug":"Markdown","permalink":"https://blog.amoswu.top/tags/Markdown/"}]},{"title":"使用计算机有感","slug":"使用计算机有感","date":"2020-11-19T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"f5cf.html","link":"","permalink":"https://blog.amoswu.top/f5cf.html","excerpt":"","text":"最近在收听万维钢老师的《精英日课4》，听到“像高手一样使用你的计算机”这一节时，有一些感触，于是我将它发到了评论区，今天抽时间同步到我的博客。 作为重度“折腾”计算机的爱好者，从高中开始收集各种计算机工具，至今也折腾了上千个工具了。听完万老师这一讲，下面我以Windows操作系统为例，分享几点我的计算机“折腾”经历和看法。 1.用键盘，别用鼠标这一点我非常赞同。用久了计算机之后，我越来越习惯于将双手放置于键盘之上，而不是一只手在键盘上一只手在鼠标上。在这里分享两点小技巧，希望能为同学们消除一些使用键盘的障碍。 【启动软件】使用Wox + Everything 或按下 Window + R 输入“软件英文名.exe”，键盘搞定所有软件、工具的启动； 【快捷键】除了文中提到的快捷键外，你还可以开拓更多的快捷键，如 Ctrl + A 全选，PageUp/PageDown 上一页/下一页，Home/End 移动到开头/结尾，F2 重命名，F11 浏览器全屏（看得到电子书时我都这样打开全屏）……当然这些远远不够，你还可以使用搜索引擎搜索关键字“软件名 + 快捷键 ”来解锁更多快捷键； 2.把事情自动化这个部分想说的有很多，今天先给非计算机背景的同学分享两点实用小技巧。 【1】在线收集表或许是你最简单的自动化工具。目前，我们工作和学习过程中难免会遇到收集各种各样信息的情况，我认为，任何信息的收集都能被规范化、自动化。使用腾讯文档、石墨文档、金数据等在线收集工具，他们已经将复杂的逻辑“折叠”进了简单的操作中，而我们只需转发一个链接。 【2】Excel 公式或许是你数据处理的好帮手。收集完信息，我们要处理的是许许多多的数据，难免需要用到Excel这样的工具，好在有公式可以帮我们剩下大量的重复一个动作的时间。还有，Python + Excel 会有更好的效果哦~ 3.建立自己的系统这也是我近半年来一直研究的问题。目前，我的解决方案是：非敏感信息——幕布+语雀+印象笔记，每周同步至本地NAS；敏感信息——密码-bitwarden，云文件、文档-NextCloud，这两部分全部存放于本地NAS。文件分享——个人CDN、快传（文叔叔，奶牛快传等等）、天翼云盘。另外，文档书写方面，我现在是重度Markdown爱好者，期待知识城邦能尽快支持Markdown啊~ 4.把所有东西放在“云”上这里的云就有很多了，我用的最熟练的还是自建个人云（NAS）方案，能WebDav搞定的，绝不让信息流到其他地方。 5.要折腾听到这里的时候，我非常感慨。大学期间，帮老师同学修电脑的时候，发现好多人都知道自己的电脑用起来不顺手，却又不去改造它。我的观点和万老师一样，要主动折腾，而不是被动使用。这几年，我对计算机软硬件的折腾有很多，以至于一出现打开PPT不播放、播放视频不全屏、垃圾软件充斥整个电脑这些现象时就会引起我的不舒适。同时，我也在改变这些现象时做了一些努力，如：在知识城邦以ppt的形式推荐好用的工具、在公司建立内网专用软件工具拓展库等等。 今天说的有点多，如果得到的同学们有这方面的疑惑，欢迎一起探讨~ 今天就说到这里，在最后我附上我的得到学生证。如果你也是“我辈中人”，很期待与你交流。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://blog.amoswu.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"随笔","slug":"随笔","permalink":"https://blog.amoswu.top/tags/%E9%9A%8F%E7%AC%94/"},{"name":"2020","slug":"2020","permalink":"https://blog.amoswu.top/tags/2020/"},{"name":"新知识","slug":"新知识","permalink":"https://blog.amoswu.top/tags/%E6%96%B0%E7%9F%A5%E8%AF%86/"}]},{"title":"浅谈互联网下载查毒","slug":"浅谈互联网下载查毒","date":"2020-09-15T16:00:00.000Z","updated":"2026-01-30T07:08:16.000Z","comments":true,"path":"f455.html","link":"","permalink":"https://blog.amoswu.top/f455.html","excerpt":"","text":"背景在互联网经过几十年的发展后，信息爆炸的时代真正地到来了。每天我们需要处理、识别、使用不同来源的信息，这些信息就像花园里自然生长的花草，有的长，有的短，有的营养丰富，有的剧毒无比。 网络病毒，就是致使美丽的“花草”中毒的根源。网络病毒，广义上被认为可以通过网络传播，同时破坏某些网络组件（服务器、客户端、交换机和路由器）的病毒；狭义上则被认为是局限于网络范围内的病毒。网络病毒多在微软开发并维护的Windows操作系统中传播。 网络病毒从不同角度有着不同的分类方式。从功能来分，可以分为木马病毒和蠕虫病毒。其中木马病毒属于一种后门程序，有的为了窃取用户隐私数据（如社交应用的账号密码、游戏账号等等），有的则为了破坏计算机及计算机内的数据，木马病毒危害能力没有蠕虫病毒来的迅猛。蠕虫病毒传播途径很广，它可以利用操作系统和程序的漏洞主动发起攻击，它还可以主动发送计算机的漏洞模块数据，从而感染局域网或者互联网内的所有计算机。从传播途径来分，有邮件型病毒和漏洞型病毒。 在简单了解了计算机病毒的来源、危害及传播途径之后，我们应该树立起“防毒”意识，主动查毒，发现一个上报一个。 从下载文件谈起身处中国，我们应感到荣幸。在国家层面很早就建立起了防火墙，也就是我们熟知的GFW，这样可以过滤大量的不良信息、有毒文件等等。在国内互联网飞速发展的背景下，我们国家涌现出了一大批优秀的安全技术攻坚团队，他们不断迭代自己的产品，并将其免费提供给大众使用，这些安全产品守护了每一台设备的安全。 今天，我就从一个具体而又常见的实例说一说如何避免下载文件带来的病毒威胁。 日常生活中，使用电脑下载互联网上的文件是我们最常用的操作之一。我们下载文件的习惯大概可以分为两类，一类是从安全软件自带的应用商店进行下载和安装，这些常见的应用商店有360软件中心、腾讯应用中心等等；另一类是通过网络地址下载，这里的地址种类大概有软件官网、下载站、网盘、即时通讯软件等等。 两类下载来源安全性如何？先说第一类，这类下载来源的大多数软件都是安全的，这里的大多数用数字表示约为99%。也就是说，正常下，没问题。 再说第二类，通过这类方式下载文件的原因其实有很多，比如电脑中没有第一类软件，第一类软件里没有要下载的文件，想下破解版软件，自己写的软件等等。这类来源相对复杂，这里面可以肯定的是只要是官网下载的100%是安全的，前提是找到真正的官网！！！ 如何提高下载来源的安全性？说了这么多，还是存在很大一部分不安全的因素。读到这里，你可能心生疑问，这些因素难道不能一股脑解决吗？ 可以解决。通过下载后的压缩包查毒这种方式，可以避免99%的互联网文件病毒。当然，查毒方式不能太单一， 必须集合了多个国家不同版本的病毒库才会有效。 有什么具体推荐？这里推荐两个在线查毒网站，操作都很简单，将下载好的压缩文件点击上传，等待片刻即可获得具有唯一MD5编号的查毒报告。 Virustotal https://www.virustotal.com/ 全球最大的在线查毒网站，几十个国家不同团队的病毒库作为核心检测源，最大支持单次上传500M文件。 左上角的0表示该文件威胁为0，安全。 腾讯哈勃 https://habo.qq.com/ 国内最好用的在线查毒网站，依托腾讯的强大数据处理能力，最大支持单词上传30M文件（普通用户）。 未发现风险和轻度风险表示可以使用。 网络安全无小事信息时代正扑面而来，网络安全是每一个使用互联网的人都应该守护的准则。如果你在使用互联网过程中发现病毒或疑似病毒，你可以通过一下平台提交你的发现。 国家信息安全漏洞共享平台 https://www.cnvd.org.cn/ 金山网络-可疑文件上报 http://www.ijinshan.com/virus_report/ 360杀毒-样本上报 http://sampleup.sd.360.cn/index.php 如果你想了解最新最全面的病毒资讯，可以访问如下链接获取。 国家互联网应急中心 https://www.cert.org.cn/ 网络安全威胁信息共享平台 https://share.anva.org.cn/index 相关参考： [1]. 百度百科-网络病毒词条","categories":[{"name":"科普","slug":"科普","permalink":"https://blog.amoswu.top/categories/%E7%A7%91%E6%99%AE/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"随笔","slug":"随笔","permalink":"https://blog.amoswu.top/tags/%E9%9A%8F%E7%AC%94/"},{"name":"2020","slug":"2020","permalink":"https://blog.amoswu.top/tags/2020/"}]},{"title":"10年Qt开发经验总结","slug":"10年Qt开发经验总结","date":"2020-09-08T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"6ae9.html","link":"","permalink":"https://blog.amoswu.top/6ae9.html","excerpt":"","text":"这段时间，学习量陡升。遇到的问题也是五花八门，越来越多，有的在搜索引擎可以找到答案，有的则需要痛苦地耗费很长时间才能寻到一丝解决方法，还有的直接就找不到答案。这也让我更加坚定地要将自己所学所遇的知识、问题，所踩过的坑都要记录下来，利己也利他。 废话不多说了，今天要带来的是一篇万字长文，是一位有着10多年 Qt 开发经验的大佬在他的博客、Github、Gitee上分享过的一篇经验贴。我用了一天的时间将其中的经验重新排版、整理，对自己遇到过的坑也进行了相应的更新，形成此篇。后续我也会将遇到的新问题、新坑一并更新到这里。这个既是经验贴，也是避坑指南，愿读到此篇的你，Qt 编程道路一路平坦~ 1最近一次更新时间：2020-09-09 18:00 原文地址 Gitee ‧ 飞扬青云 最近更新 2020/09/04 09:07 ### 一、开发经验总结 当编译发现大量错误的时候，从第一个看起，一个一个的解决，不要急着去看下一个错误，往往后面的错误都是由于前面的错误引起的，第一个解决后很可能都解决了。 定时器是个好东西，学会好使用它，有时候用QTimer::singleShot可以解决意想不到的问题。 打开 Qt Creator，在构建套件的环境中增加MAKEFLAGS=-j8，可以不用每次设置多线程编译。珍爱时间和生命。新版的 Qt Creator 已经默认就是j8。 如果你想顺利用 QtCreator 部署安卓程序，首先你要在 AndroidStudio 里面配置成功，把坑全部趟平。 很多时候找到 Qt 对应封装的方法后，记得多看看该函数的重载，多个参数的，你会发现不一样的世界，有时候会恍然大悟，原来Qt已经帮我们封装好了。 绘制平铺背景QPainter::drawTiledPixmap,绘制圆角矩形QPainter::drawRoundedRect(),而不是 QPainter::drawRoundRect() 。 Qt5 增强了很多安全性验证，如果出现setGeometry: Unable to set geometry，请将该控件的可见移到加入布局之后。 对 QLCDNumber 控件设置样式，需要将 QLCDNumber 的 segmentstyle 设置为 flat 。 使用弱属性机制，可以存储临时的值用于传递判断。可以通过widget-&gt;dynamicPropertyNames()列出所有弱属性名称，然后通过widget-&gt;property(&quot;name&quot;)取出对应的弱属性的值。 在开发时, 无论是出于维护的便捷性, 还是节省内存资源的考虑, 都应该有一个 qss 文件来存放所有的样式表, 而不应该将 setStyleSheet 写的到处都是。如果是初学阶段或者测试阶段可以直接 UI 上右键设置样式表，正式项目还是建议统一到一个 qss 样式表文件比较好，统一管理。 如果出现 Z-order assignment: is not a valid widget. 错误提示，用记事本打开对应的 ui 文件，找到&lt;zorder&gt;&lt;/zorder&gt; 为空的地方，删除即可。 善于利用 QComboBox 的 addItem 的第二个参数设置用户数据，可以实现很多效果，使用itemData 取出来。 如果用了 webengine 模块，发布程序的时候要带上 QtWebEngineProcess.exe + translations文件夹 + resources文件夹。 默认 Qt 是一个窗体一个句柄，如果要让每个控件都拥有独立的句柄，设置下 a.setAttribute(Qt::AA_NativeWindows) 。 可以对整体的指示器设置样式，例如 *::down-arrow,*::menu-indicator&#123;&#125; *::up-arrow:disabled,*::up-arrow:off&#123;&#125;。 嵌入式 linux 运行 Qt 程序 Qt4 写法：./HelloQt -qws &amp; Qt5写法：./HelloQt --platform xcb。 Qt Creator 软件的配置文件存放在：C:\\Users\\Administrator\\AppData\\Roaming\\QtProject，有时候如果发现出问题了，将这个文件夹删除后打开 Qt Creator 自动重新生成即可。 QMediaPlayer 是个壳，依赖本地解码器，视频这块默认基本上就播放个 MP4 ，如果要支持其他格式需要下载 k-lite 或者 LAV Filters 安装即可（WIN上，其他系统上自行搜索）。如果需要做功能强劲的播放器，初学者建议用 vlc、mpv，终极大法用 ffmpeg。 获取标题栏高度：style()-&gt;pixelMetric(QStyle::PM_TitleBarHeight); PM_TitleBarHeight 点进去你会发现新大陆。 清空数据表并重置自增ID，sql = truncate table table_name。 如果运行程序出现 Fault tolerant heap shim applied to current process. This is usually due to previous crashes. 错误。 办法：打开注册表，找到HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Layers\\，选中Layers键值，从右侧列表中删除自己的那个程序路径即可。 Qt 内置了 QFormLayout 表单布局用于自动生成标签 + 输入框的组合的表单界面。 qml 播放视频在 linux 需要安装 libpulse-dev , sudo apt-get install libpulse-dev。 可以直接继承 QSqlQueryModel 实现自定义的 QueryModel ，比如某一列字体颜色，占位符，其他样式等，重写 QVariant CustomSqlModel::data(const QModelIndex &amp;index, int role) const 。 QPushButton 左对齐文字，需要设置样式表 QPushButton&#123;text-align:left;&#125; 。 多种预定义变量 #if (defined webkit) || (defined webengine)，去掉生成空的debug 和 release 目录 CONFIG -= debug_and_release。 新版的 Qtcreator 增强了语法检查，会弹出很多警告提示等，可以在插件列表中关闭 clang 打头的几个即可，Help &gt;&gt; About Plugins 。也可以设置代码检查级别，Tools &gt;&gt; Options &gt;&gt; C++ &gt;&gt; Code Model 。 如果需要指定无边框窗体，但是又需要保留操作系统的边框特性，可以自由拉伸边框，可以使用 setWindowFlags(Qt::CustomizeWindowHint) 。 有时候在界面上加了弹簧，需要动态改变弹簧对应的拉伸策略，对应方法为 changeSize，很多人会选择使用 set 开头去找，找不到的。 在使用 QFile 的过程中，不建议频繁的打开文件写入然后再关闭文件，比如：间隔 5ms 输出日志，IO性能瓶颈很大，这种情况建议先打开文件不要关闭，等待合适的时机，可以在析构函数中或者日期变了需要重新变换日志文件的时候关闭文件。不然短时间内大量的打开关闭文件会很卡，文件越大越卡。 如果程序打包好以后弹出提示 This application failed to start because it could not find or load the Qt platform plugin 一般都是因为 platforms 插件目录未打包或者打包错了的原因导致的。 非常不建议 tr 中包含中文，尽管现在的新版Qt支持中文到其他语言的翻译，但是很不规范，也不知道 TMD 是谁教的，tr的本意是包含英文，然后翻译到其他语言比如中文，现在大量的初学者滥用 tr ，如果没有翻译的需求，禁用 tr ，tr 需要开销的，Qt默认会认为他需要翻译，会额外进行特殊处理。 建议进行中文兼容时使用如下代码： QString s = QString::fromUtf8(&quot;这是一个 UTF-8 的字符串 &quot;);； QString s = QStringLiteral(&quot;这是一个 UTF-8 的字符串 &quot;);。 很多人 Qt 和 Qt Creator 傻傻分不清楚，经常问 Qt 什么版本结果发一个 Qt Creator 的版本过来，Qt Creator 是使用 Qt 编写的集成开发环境 IDE ，和宇宙第一的 Visual Studio 一样，他可以是 msvc 编译器的（ WIN 对应的 Qt 集成安装环境中自带的 Qt Cerator 是 msvc 的），也可以是 mingw 编译的，还可以是gcc的。如果是自定义控件插件，需要集成到Qt Creator中，必须保证该插件的动态库文件（dll或者so等文件）对应的编译器和Qt版本以及位数和Qt Creator的版本完全一致才行，否则基本不大可能集成进去。特别注意的是Qt集成环境安装包中的Qt版本和Qt Creator版本未必完全一致，必须擦亮眼睛看清楚，有些是完全一致的。 超过两处相同处理的代码，建议单独写成函数。代码尽量规范精简，比如 if(a == 123) 要写成 if (123 == a)，值在前面，再比如 if (ok == true) 要写成 if (ok)，if (ok == false) 要写成 if (!ok)等。 很多人问Qt嵌入式平台用哪个好，这里统一回答（当前时间节点2018年）：imx6 + 335x比较稳定，性能高就用 RK3288 RK3399，便宜的话就用全志H3，玩一玩可以用树莓派、香橙派。 对于大段的注释代码，建议用 #if 0 #endif 将代码块包含起来，而不是将该段代码选中然后全部 // ，下次要打开这段代码的话，又需要重新选中一次取消，如果采用的是 #if 0则只要把0改成1即可，效率大大提升。 Qt打包发布，有很多办法，Qt5 以后提供了打包工具 windeployqt（ linux上为linuxdeployqt，mac上为 macdeployqt ）可以很方便的将应用程序打包，使用下来发现也不是万能的，有时候会多打包一些没有依赖的文件，有时候又会忘记打包一些插件尤其是用了 qml 的情况下，而且不能识别第三方库，比如程序依赖 ffmpeg ，则对应的库需要自行拷贝，终极大法就是将你的可执行文件复制到Qt安装目录下的 bin 目录，然后整个一起打包，挨个删除不大可能依赖的组件，直到删到正常运行为止。 Qt中的动画，底层用的是 QElapsedTimer 定时器来完成处理，比如产生一些指定规则算法的数据，然后对属性进行处理。 不要把 d 指针看的很玄乎，其实就是在类的实现文件定义了一个私有类，用来存放局部变量，个人建议在做一些小项目时，没有太大必要引入这种机制，会降低代码可读性，增加复杂性，新手接受项目后会看的很懵逼。 很多人在绘制的时候，设置画笔以为就只可以设置个单调的颜色，其实QPen还可以设置brush，这样灵活性就提高不知道多少倍，比如设置 QPen 的 brush 以后，可以使用各种渐变，比如绘制渐变颜色的进度条和文字等，而不再是单调的一种颜色。 示例： 12345678910QPainter painter(this);QPen pen; // creates a default penpen.setStyle(Qt::DashDotLine);pen.setWidth(3);pen.setBrush(Qt::green);pen.setCapStyle(Qt::RoundCap);pen.setJoinStyle(Qt::RoundJoin);painter.setPen(pen); 很多控件都带有 viewport ，比如 QTextEdit / QTableWidget / QScrollArea，有时候对这些控件直接处理的时候发现不起作用，需要对其 viewport() 设置才行，比如设置滚动条区域背景透明，需要使用 scrollArea-&gt;viewport()-&gt;setStyleSheet(&quot;background-color:transparent;&quot;); 而不是 scrollArea-&gt;setStyleSheet(&quot;QScrollArea&#123;background-color:transparent;&#125;&quot;); 。 有时候设置了鼠标跟踪 setMouseTracking 为真，如果该窗体上面还有其他控件，当鼠标移到其他控件上面的时候，父类的鼠标移动事件MouseMove识别不到了，此时需要用到HoverMove 事件，需要先设置 setAttribute(Qt::WA_Hover, true); 。 在我们使用 QList、QStringList、QByteArray 等链表或者数组的过程中，如果只需要取值，而不是赋值，强烈建议使用 at() 取值而不是 [] 操作符，在官方书籍《C++ GUI Qt 4编程（第二版）》的书中有特别的强调说明，此教材的原作者据说是Qt开发的核心人员编写的，所以还是比较权威，至于使用 at() 与使用 [] 操作符速度效率的比较，网上也有网友做过此类对比。 原文在书的212页，这样描述的： Qt对所有的容器和许多其他类都使用隐含共享，隐含共享是Qt对不希望修改的数据决不进行复制的保证，为了使隐含共享的作用发挥得最好，可以采用两个新的编程习惯。第一种习惯是对于一个（非常量的）向量或者列表进行只读存取时，使用 at() 函数而不用 [] 操作符，因为Qt的容器类不能辨别 [] 操作符是否将出现在一个赋值的左边还是右边，他假设最坏的情况出现并且强制执行深层赋值，而 at() 函数则不被允许出现在一个赋值的左边。 安全的删除 Qt 的对象类，强烈建议使用 deleteLater 而不是 delete ，因为deleteLater会选择在合适的时机进行释放，而delete会立即释放，很可能会出错崩溃。如果要批量删除对象集合，可以用 qDeleteAll ，比如 qDeleteAll(btns) 。 在 QTableView 控件中，如果需要自定义的列按钮、复选框、下拉框等其他模式显示，可以采用自定义委托 QItemDelegate 来实现，如果需要禁用某列，则在自定义委托的重载createEditor 函数返回0即可。自定义委托对应的控件在进入编辑状态的时候出现，如果想一直出现，则需要重载paint函数用 drawPrimitive 或者 drawControl 来绘制。 将 QApplication::style() 对应的 drawPrimitive 、drawControl、drawItemText、drawItemPixmap等几个方法用熟悉了，再结合QStyleOption属性，可以玩转各种自定义委托，还可以直接使用paint函数中的painter进行各种绘制，各种牛逼的表格、树状列表、下拉框等，绝对屌炸天。QApplication::style()-&gt;drawControl 的第4个参数如果不设置，则绘制出来的控件不会应用样式表。 心中有坐标，万物皆 painter，强烈建议在学习自定义控件绘制的时候，将 qpainter.h 头文件中的函数全部看一遍、试一遍、理解一遍，这里边包含了所有Qt内置的绘制的接口，对应的参数都试一遍，你会发现很多新大陆，会大大激发你的绘制的兴趣，犹如神笔马良一般，策马崩腾遨游代码绘制的世界。 理论上串口和网络收发数据都是默认异步的，操作系统自动调度，完全不会卡住界面，网上那些说收发数据卡住界面主线程的都是扯几把蛋，真正的耗时是在运算以及运算后的处理，而不是收发数据，在一些小数据量运算处理的项目中，一般不建议动用线程去处理，线程需要调度开销的，不要什么东西都往线程里边扔，线程不是万能的。只有当真正需要将一些很耗时的操作比如编码解码等，才需要移到线程处理。 在构造函数中获取控件的宽高很可能是不正确的，需要在控件首次显示以后再获取才是正确的，控件是在首次显示以后才会设置好正确的宽高值，记住是在首次显示以后，而不是构造函数或者程序启动好以后，如果程序启动好以后有些容器控件比如 QTabWidget 中的没有显示的页面的控件，你去获取宽高很可能也是不正确的，万无一失的办法就是首次显示以后去获取。 数据库处理一般建议在主线程，如果非要在其他线程，务必记得打开数据库也要在那个线程，即在那个线程使用数据库就在那个线程打开，不能打开数据库在主线程，执行 sql 在子线程，很可能出问题。 Qt中的 QString 和 const char * 之间转换，最好用 toStdString().c_str() 而不是 toLocal8Bit().constData() ，比如在 setProperty 中如果用后者，字符串中文就会不正确，英文正常。 Qt 的信号槽机制非常牛逼，也是 Qt 的独特的核心功能之一，有时候我们在很多窗体中传递信号来实现更新或者处理，如果窗体层级比较多，比如窗体 A 的父类是窗体 B ，窗体 B 的父类是窗体 C ，窗体 C 有个子窗体 D ，如果窗体 A 一个信号要传递给窗体 D ，问题来了，必须先经过窗体 B 中转到窗体 C 再到窗体 D 才行，这样的话各种信号关联信号的 connect 会非常多而且管理起来比较乱，可以考虑增加一个全局的单例类 AppEvent ，公共的信号放这里，然后窗体A对应信号绑定到 AppEvent ，窗体 D 绑定 AppEvent 的信号到对应的槽函数即可，干净清爽整洁。 QTextEdit 右键菜单默认英文的，如果想要中文显示，加载 widgets.qm 文件即可，一个 Qt 程序中可以安装多个翻译文件，不冲突。 Qt 中有个全局的焦点切换信号 focusChanged ，可以用它做自定义的输入法。Qt4中默认会安装输入法上下文，比如在main函数打印 a.inputContext 会显示值，这个默认安装的输入法上下文，会拦截两个牛逼的信号 QEvent::RequestSoftwareInputPanel 和QEvent::CloseSoftwareInputPanel ，以至于就算你安装了全局的事件过滤器依然识别不到这两个信号，你只需要在 main 函数执行 a.setInputContext(0) 即可，意思是安装输入法上下文为空。 在 Qt5.10 以后，表格控件 QTableWidget 或者 QTableView 的默认最小列宽改成了15，以前的版本是 0 ，所以在新版的qt中，如果设置表格的列宽过小，不会应用，取的是最小的列宽。所以如果要设置更小的列宽需要重新设置 ui-&gt;tableView-&gt;horizontalHeader()-&gt;setMinimumSectionSize(0);。 Qt 支持所有的界面控件比如 QPushButton、QLineEdit 自动关联 on_控件名_信号(参数) 信号槽，比如按钮的单击信号 on_pushButton_clicked()，然后直接实现槽函数即可。 setPixmap 是最糟糕的贴图方式，一般只用来简单的不是很频繁的贴图，频繁的建议painter 绘制，默认双缓冲，在高级点用 opengl 绘制，利用 GPU 。 如果需要在尺寸改变的时候不重绘窗体，则设置属性即可 this-&gt;setAttribute(Qt::WA_StaticContents, true); 这样可以避免可以避免对已经显示区域的重新绘制。 默认程序中获取焦点以后会有虚边框，如果看着觉得碍眼不舒服可以去掉，设置样式即可：setStyleSheet(&quot;*&#123;outline:0px;&#125;&quot;);。 从 Qt4 转到 Qt5 ，有些类的方法已经废弃或者过时了，如果想要在 Qt5 中启用 Qt4 的方法，比如 QHeadView 的 setMovable，可以在你的 pro 或者 pri 文件中加上一行即可：DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0 。 QString 的 replace 函数会改变原字符串，切记，他在返回替换后的新字符串的同时也会改变原字符串，我的乖乖！ QGraphicsEffect 类的相关效果很炫，可以实现很多效果比如透明、渐变、阴影等，但是该类很耗 CPU，如果不是特别需要一般不建议用，就算用也是要用在该部件后期不会发生频繁绘制的场景，不然会让你哭晕在厕所。 巧用 QMetaObject::invokeMethod 方法可以实现很多效果，包括同步和异步执行，比如有个应用场景是在回调中，需要异步调用一个public函数，如果直接调用的话会发现不成功，此时需要使用 QMetaObject::invokeMethod(obj, &quot;fun&quot;, Qt::QueuedConnection); 这种方式来就可以。invokeMethod 函数有很多重载参数，可以传入返回值和执行方法的参数等。 Qt5 中的信号是 public 的，可以在需要的地方直接 emit 即可，而在Qt4中信号是 protected的，不能直接使用，需要定义一个 public 函数来 emit 。 Qt5.15 版本开始官方不再提供安装包，只提供源码，可以自行编译或者在线安装，估计每次编译各种版本太麻烦，更多的是为了统计收集用户使用信息比如通过在线安装，后期可能会逐步加大商业化力度。 很多初学者甚至几年工作经验的人，对多线程有很深的误解和滥用，尤其是在串口和网络通信这块，什么都往多线程里面丢，一旦遇到界面卡，就把数据收发啥的都搞到多线程里面去，殊不知绝大部分时候那根本没啥用，因为没找到出问题的根源。 如果你没有使用 wait*** 函数的话，大部分的界面卡都出在数据处理和展示中，比如传过来的是一张图片的数据，你需要将这些数据转成图片，这个肯定是耗时的； 还有就是就收到的数据曲线绘制出来，如果过于频繁或者间隔过短，肯定会给 UI 造成很大的压力的，最好的办法是解决如何不要频繁绘制 UI 比如合并数据一起绘制等； 如果是因为绘制 UI 造成的卡，那多线程也是没啥用的，因为 UI 只能在主线程； 串口和网络的数据收发默认都是异步的，由操作系统调度的，如果数据处理复杂而且数据量大，你要做的是将数据处理放到多线程中； 如果没有严格的数据同步需求，根本不需要调用 wait*** 之类的函数来立即发送和接收数据，实际需求中大部分的应用场景其实异步收发数据就足够了； 有严格数据同步需求的场景还是放到多线程会好一些，不然你 wait*** 就卡在那边了； 多线程是需要占用系统资源的，理论上来说，如果线程数量超过了 CPU 的核心数量，其实多线程调度可能花费的时间更多，各位在使用过程中要权衡利弊； MSVC编译器的选择说明 如果是32位的 Qt 则编译器选择 x86 开头的 如果是64位的 Qt 则编译器选择 amd64 开头的 具体是看安装的 Qt 构建套件版本以及目标运行平台的系统位数和架构 一般现在的电脑默认以64位的居多，选择 amd64 即可 如果用户需要兼容32位的系统则建议选择32位的 Qt ，这样即可在32位也可以在64位系统运行 诸葛大佬补充：x86 / x64 都是编译环境和运行环境相同，没有或。带下划线的就是交叉编译，前面是编译环境，后面是运行环境。 名称 说明 x86 32/64位系统上编译在32/64位系统上运行 x86_amd64 32/64位系统上编译在64位系统上运行 x86_arm 32/64位系统上编译在arm系统上运行 amd64 64位系统上编译在64位系统上运行 amd64_x86 64位系统上编译在32/64位系统上运行 amd64_arm 64位系统上编译在arm系统上运行 Qt默认不支持大资源文件，比如添加了字体文件，需要 pro 文件开启 CONFIG += resources_big 。 运行文件附带调试输出窗口 CONFIG += console pro。 可以在 pro 文件中写上标记版本号 + ico 图标（Qt5才支持） 12VERSION = 2020.10.25RC_ICONS = main0.ico 管理员运行程序，限定在MSVC编译器。 12QMAKE_LFLAGS += /MANIFESTUAC:&quot;level=&#x27;requireAdministrator&#x27; uiAccess=&#x27;false&#x27;&quot; #以管理员运行QMAKE_LFLAGS += /SUBSYSTEM:WINDOWS,&quot;5.01&quot; #VS2013 在XP运行 移除旧的样式 1234//移除原有样式style()-&gt;unpolish(ui-&gt;btn);//重新设置新的该控件的样式。style()-&gt;polish(ui-&gt;btn); 获取类的属性 12345678const QMetaObject *metaobject = object-&gt;metaObject();int count = metaobject-&gt;propertyCount();for (int i = 0; i &lt; count; ++i) &#123; QMetaProperty metaproperty = metaobject-&gt;property(i); const char *name = metaproperty.name(); QVariant value = object-&gt;property(name); qDebug() &lt;&lt; name &lt;&lt; value;&#125; Qt内置图标封装在QStyle中，大概七十多个图标，可以直接拿来用。 123456789SP_TitleBarMenuButton,SP_TitleBarMinButton,SP_TitleBarMaxButton,SP_TitleBarCloseButton,SP_MessageBoxInformation,SP_MessageBoxWarning,SP_MessageBoxCritical,SP_MessageBoxQuestion,... 根据操作系统位数判断加载 1234win32 &#123; contains(DEFINES, WIN64) &#123; DESTDIR = $$&#123;PWD&#125;/../../bin64 &#125; else &#123; DESTDIR = $$&#123;PWD&#125;/../../bin32 &#125;&#125; 可以将控件 A 添加到布局，然后控件 B 设置该布局，这种灵活性大大提高了控件的组合度，比如可以在文本框左侧右侧增加一个搜索按钮，按钮设置图标即可。 123456QPushButton *btn = new QPushButton;btn-&gt;resize(30, ui-&gt;lineEdit-&gt;height());QHBoxLayout *layout = new QHBoxLayout(ui-&gt;lineEdit);layout-&gt;setMargin(0);layout-&gt;addStretch();layout-&gt;addWidget(btn); 巧妙的使用 findChildren 可以查找该控件下的所有子控件。findChild 为查找单个。 123456//查找指定类名objectName的控件QList&lt;QWidget *&gt; widgets = parentWidget.findChildren&lt;QWidget *&gt;(&quot;widgetname&quot;);//查找所有QPushButtonQList&lt;QPushButton *&gt; allPButtons = parentWidget.findChildren&lt;QPushButton *&gt;();//查找一级子控件,不然会一直遍历所有子控件QList&lt;QPushButton *&gt; childButtons = parentWidget.findChildren&lt;QPushButton *&gt;(QString(), Qt::FindDirectChildrenOnly); 巧妙的使用 inherits 判断是否属于某种类。 1234QTimer *timer = new QTimer; // QTimer inherits QObjecttimer-&gt;inherits(&quot;QTimer&quot;); // returns truetimer-&gt;inherits(&quot;QObject&quot;); // returns truetimer-&gt;inherits(&quot;QAbstractButton&quot;); // returns false Qt + Android 防止程序被关闭。 1234567#if defined(Q_OS_ANDROID)QAndroidService a(argc, argv);return a.exec()#elseQApplication a(argc, argv);return a.exec();#endif 可以执行位置设置背景图片。 123456QMainWindow &gt; .QWidget &#123; background-color: gainsboro; background-image: url(:/images/pagefold.png); background-position: top right; background-repeat: no-repeat&#125; 判断编译器类型、编译器版本、操作系统。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//GCC编译器#ifdef __GNUC__#if __GNUC__ &gt;= 3 // GCC3.0以上//MSVC编译器#ifdef _MSC_VER#if _MSC_VER &gt;=1000 // VC++4.0以上#if _MSC_VER &gt;=1100 // VC++5.0以上#if _MSC_VER &gt;=1200 // VC++6.0以上#if _MSC_VER &gt;=1300 // VC2003以上#if _MSC_VER &gt;=1400 // VC2005以上#if _MSC_VER &gt;=1500 // VC2008以上#if _MSC_VER &gt;=1600 // VC2010以上#if _MSC_VER &gt;=1700 // VC2012以上#if _MSC_VER &gt;=1800 // VC2013以上#if _MSC_VER &gt;=1900 // VC2015以上//Borland C++#ifdef __BORLANDC__//Cygwin#ifdef __CYGWIN__#ifdef __CYGWIN32__//mingw#ifdef __MINGW32__//windows#ifdef _WIN32 //32bit#ifdef _WIN64 //64bit#ifdef _WINDOWS //图形界面程序#ifdef _CONSOLE //控制台程序//Windows（95/98/Me/NT/2000/XP/Vista）和Windows CE都定义了#if (WINVER &gt;= 0x030a) // Windows 3.1以上#if (WINVER &gt;= 0x0400) // Windows 95/NT4.0以上#if (WINVER &gt;= 0x0410) // Windows 98以上#if (WINVER &gt;= 0x0500) // Windows Me/2000以上#if (WINVER &gt;= 0x0501) // Windows XP以上#if (WINVER &gt;= 0x0600) // Windows Vista以上//_WIN32_WINNT 内核版本#if (_WIN32_WINNT &gt;= 0x0500) // Windows 2000以上#if (_WIN32_WINNT &gt;= 0x0501) // Windows XP以上#if (_WIN32_WINNT &gt;= 0x0600) // Windows Vista以上 在 pro 中判断 Qt 版本及构建套件位数 1234567891011121314151617181920212223#打印版本信息message(qt version: $$QT_VERSION)#判断当前qt版本号QT_VERSION = $$[QT_VERSION]QT_VERSION = $$split(QT_VERSION, &quot;.&quot;)QT_VER_MAJ = $$member(QT_VERSION, 0)QT_VER_MIN = $$member(QT_VERSION, 1)#下面是表示 Qt5.5greaterThan(QT_VER_MAJ, 4) &#123;greaterThan(QT_VER_MIN, 4) &#123;#自己根据需要做一些处理&#125;&#125;#QT_ARCH是Qt5新增的,在Qt4上没效果#打印当前Qt构建套件的信息message($$QT_ARCH)#表示arm平台构建套件contains(QT_ARCH, arm) &#123;&#125;#表示32位的构建套件contains(QT_ARCH, i386) &#123;&#125;#表示64位的构建套件contains(QT_ARCH, x86_64) &#123;&#125; Qt 最小化后恢复界面假死冻结，加上代码 12345void showEvent(QShowEvent *e)&#123; setAttribute(Qt::WA_Mapped); QWidget::showEvent(e);&#125; 设置高分屏属性以便支持 2K 、4K 等高分辨率，尤其是手机 app 。必须写在 main 函数的QApplication a(argc, argv); 的前面。 123#if (QT_VERSION &gt; QT_VERSION_CHECK(5,6,0)) QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling);#endif Qt5 以后提供了类 QScroller 直接将控件滚动。 1234567891011//禁用横向滚动条ui-&gt;listWidget-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);//禁用纵向滚动条ui-&gt;listWidget-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);//设置横向按照像素值为单位滚动ui-&gt;listWidget-&gt;setHorizontalScrollMode(QListWidget::ScrollPerPixel);//设置纵向按照像素值为单位滚动ui-&gt;listWidget-&gt;setVerticalScrollMode(QListWidget::ScrollPerPixel);//设置滚动对象以及滚动方式为鼠标左键拉动滚动QScroller::grabGesture(ui-&gt;listWidget, QScroller::LeftMouseButtonGesture);//还有个QScrollerProperties可以设置滚动的一些参数 如果使用 sqlite 数据库不想产生数据库文件，可以创建内存数据库。 12QSqlDatabase db = QSqlDatabase::addDatabase(&quot;QSQLITE&quot;);db.setDatabaseName(&quot;:memory:&quot;); Qtchart 模块从 Qt5.7 开始自带，最低编译要求 Qt5.4 。在安装的时候记得勾选，默认不勾选。使用该模块需要引入命名空间。 123#include &lt;QChartView&gt;QT_CHARTS_USE_NAMESPACEclass CustomChart : public QChartView QLabel 有三种设置文本的方法，掌握好 Qt 的属性系统，举一反三，可以做出很多效果。 123ui-&gt;label-&gt;setStyleSheet(&quot;qproperty-text:hello;&quot;);ui-&gt;label-&gt;setProperty(&quot;text&quot;, &quot;hello&quot;);ui-&gt;label-&gt;setText(&quot;hello&quot;); 巧妙的用 QEventLoop 开启事件循环，可以使得很多同步获取返回结果而不阻塞界面。QEventLoop 内部新建了线程执行。 123QEventLoop loop;connect(reply, SIGNAL(finished()), &amp;loop, SLOT(quit()));loop.exec(); QSqlTableModel 的 rowCount 方法，默认最大返回256 ，如果超过256，可以将表格拉到底部，会自动加载剩余的，每次最大加载256条数据，如果需要打印或者导出数据，记得最好采用 sql 语句去查询，而不是使用 QSqlTableModel 的 rowCount 方法。不然永远最大只会导出256条数据。 如果数据量很小，也可以采用如下方法： 1234//主动加载所有数据,不然获取到的行数&lt;=256while(model-&gt;canFetchMore()) &#123; model-&gt;fetchMore();&#125; 在某些 HTTP POST数据的时候，如果采用的是 &amp; 字符串连接的数据发送，中文解析乱码的话，需要将中文进行URL转码。 12QString content = &quot;测试中文&quot;;QString note = content.toUtf8().toPercentEncoding(); Qt中继承 QWidget 之后，样式表不起作用，解决办法有三个。强烈推荐方法一。 方法一：设置属性 this-&gt;setAttribute(Qt::WA_StyledBackground, true); 方法二：改成继承 QFrame ，因为 QFrame 自带 paintEvent 函数已做了实现，在使用样式表时会进行解析和绘制。 方法三：重新实现 QWidget 的 paintEvent 函数时，使用 QStylePainter 绘制。 1234567void Widget::paintEvent(QPaintEvent *)&#123; QStyleOption option; option.initFrom(this); QPainter painter(this); style()-&gt;drawPrimitive(QStyle::PE_Widget, &amp;option, &amp;painter, this);&#125; 在很多网络应用程序，需要自定义心跳包来保持连接，不然断电或者非法关闭程序，对方识别不到，需要进行超时检测，但是有些程序没有提供心跳协议，此时需要启用系统层的保活程序，此方法适用于TCP连接。 123456789int fd = tcpSocket-&gt;socketDescriptor();int keepAlive = 1; //开启keepalive属性,缺省值:0(关闭)int keepIdle = 5; //如果在5秒内没有任何数据交互,则进行探测,缺省值:7200(s)int keepInterval = 2; //探测时发探测包的时间间隔为2秒,缺省值:75(s)int keepCount = 2; //探测重试的次数,全部超时则认定连接失效,缺省值:9(次)setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (void *)&amp;keepAlive, sizeof(keepAlive));setsockopt(fd, SOL_TCP, TCP_KEEPIDLE, (void *)&amp;keepIdle, sizeof(keepIdle));setsockopt(fd, SOL_TCP, TCP_KEEPINTVL, (void *)&amp;keepInterval, sizeof(keepInterval));setsockopt(fd, SOL_TCP, TCP_KEEPCNT, (void *)&amp;keepCount, sizeof(keepCount)); 在绘制无背景颜色只有边框颜色的圆形时候，可以用绘制360度的圆弧替代，效果完全一致。 1234QRect rect(-radius, -radius, radius * 2, radius * 2);//以下两种方法二选一,其实绘制360度的圆弧=绘制无背景的圆形painter-&gt;drawArc(rect, 0, 360 * 16);painter-&gt;drawEllipse(rect); Qt封装的 QDateTime 日期时间类非常强大，可以字符串和日期时间相互转换，也可以毫秒数和日期时间相互转换，还可以1970经过的秒数和日期时间相互转换等。 12345678910QDateTime dateTime;QString dateTime_str = dateTime.currentDateTime().toString(&quot;yyyy-MM-dd hh:mm:ss&quot;);//从字符串转换为毫秒（需完整的年月日时分秒）datetime.fromString(&quot;2011-09-10 12:07:50:541&quot;, &quot;yyyy-MM-dd hh:mm:ss:zzz&quot;).toMSecsSinceEpoch();//从字符串转换为秒（需完整的年月日时分秒）datetime.fromString(&quot;2011-09-10 12:07:50:541&quot;, &quot;yyyy-MM-dd hh:mm:ss:zzz&quot;).toTime_t();//从毫秒转换到年月日时分秒datetime.fromMSecsSinceEpoch(1315193829218).toString(&quot;yyyy-MM-dd hh:mm:ss:zzz&quot;);//从秒转换到年月日时分秒（若有zzz，则为000）datetime.fromTime_t(1315193829).toString(&quot;yyyy-MM-dd hh:mm:ss[:zzz]&quot;); 如果是 dialog 窗体，需要在 exec 以后还能让其他代码继续执行，请在dialog窗体exec前增加一行代码，否则会阻塞窗体消息。 123QDialog dialog;dialog.setWindowModality(Qt::WindowModal);dialog.exec(); 在使用 setItemWidget 或者 setCellWidget 的过程中，有时候会发现设置的控件没有居中显示而是默认的左对齐，而且不会自动拉伸填充，对于追求完美的程序员来说，这个可不大好看，有个终极通用办法就是，将这个控件放到一个 widget 的布局中，然后将 widget 添加到 item 中，这样就完美解决了，而且这样可以组合多个控件产生复杂的控件。 12345678910//实例化进度条控件QProgressBar *progress = new QProgressBar;//增加widget+布局巧妙实现居中QWidget *widget = new QWidget;QHBoxLayout *layout = new QHBoxLayout;layout-&gt;setSpacing(0);layout-&gt;setMargin(0);layout-&gt;addWidget(progress);widget-&gt;setLayout(layout);ui-&gt;tableWidget-&gt;setCellWidget(0, 0, widget); 很多时候需要在已知背景色的情况下，能够清晰的绘制文字，这个时候需要计算对应的文字颜色。 123//根据背景色自动计算合适的前景色double gray = (0.299 * color.red() + 0.587 * color.green() + 0.114 * color.blue()) / 255;QColor textColor = gray &gt; 0.5 ? Qt::black : Qt::white; 对 QTableView 或者 QTableWidget 禁用列拖动。 12345#if (QT_VERSION &lt;= QT_VERSION_CHECK(5,0,0)) ui-&gt;tableView-&gt;horizontalHeader()-&gt;setResizeMode(0, QHeaderView::Fixed);#else ui-&gt;tableView-&gt;horizontalHeader()-&gt;setSectionResizeMode(0, QHeaderView::Fixed);#endif Qt中的 QColor 对颜色封装的很完美，支持各种转换，比如rgb、hsb、cmyk、hsl，对应的是toRgb、toHsv、toCmyk、toHsl，还支持透明度设置，颜色值还能转成16进制格式显示。 123QColor color(255, 0, 0, 100);qDebug() &lt;&lt; color.name() &lt;&lt; color.name(QColor::HexArgb);//输出 #ff0000 #64ff0000 QVariant 类型异常的强大，可以说是万能的类型，在进行配置文件的存储的时候，经常会用到 QVariant 的转换，QVariant 默认自带了 toString 、toFloat 等各种转换，但是还是不够，比如有时候需要从QVariant转到QColor，而却没有提供toColor的函数，这个时候就要用到万能办法。 12345if (variant.typeName() == &quot;QColor&quot;) &#123; QColor color = variant.value&lt;QColor&gt;(); QFont font = variant.value&lt;QFont&gt;(); QString nodeValue = color.name(QColor::HexArgb);&#125; Qt源码中内置了一些未公开的不能直接使用的黑科技，都藏在对应模块的private中，比如 gui-private widgets-private 等，比如 zip 文件解压类 QZipReader 、压缩类 QZipWrite r就在 gui-private 模块中，需要在 pro 中引入QT += gui-private才能使用。 12345678910111213141516171819202122232425#include &quot;QtGui/private/qzipreader_p.h&quot;#include &quot;QtGui/private/qzipwriter_p.h&quot;QZipReader reader(dirPath);QString path(&quot;&quot;);//解压文件夹到当前目录reader.extractAll(path);//文件夹名称QZipReader::FileInfo fileInfo = reader.entryInfoAt(0);//解压文件QFile file(filePath);file.open(QIODevice::WriteOnly);file.write(reader.fileData(QString::fromLocal8Bit(&quot;%1&quot;).arg(filePath)));file.close();reader.close();QZipWriter *writer = new QZipWriter(dirPath);//添加文件夹writer-&gt;addDirectory(unCompress);//添加文件QFile file(filePath);file.open(QIODevice::ReadOnly);writer-&gt;addFile(data, file.readAll());file.close();writer-&gt;close(); 新版的 QTcpServer 类在64位版本的Qt下很可能不会进入 incomingConnection 函数，那是因为Qt5 对应的 incomingConnection 函数参数变了，由之前的 int 改成了 qintptr ，改成 qintptr 有个好处，在32位上自动是 quint32 而在64位上自动是 quint64 ，如果在Qt5 中继续写的参数是int 则在32位上没有问题在64位上才有问题，所以为了兼容 Qt4 和 Qt5 ，必须按照不一样的参数写。 12345#if (QT_VERSION &gt; QT_VERSION_CHECK(5,0,0)) void incomingConnection(qintptr handle);#else void incomingConnection(int handle);#endif QWebEngineView 控件由于使用了opengl，在某些电脑上可能由于 opengl 的驱动过低会导致花屏或者各种奇奇怪怪的问题，比如 showfullscreen 的情况下鼠标右键失效，需要在main函数启用软件 opengl 渲染。 123456#if (QT_VERSION &gt; QT_VERSION_CHECK(5,4,0)) //下面两种方法都可以,Qt默认采用的是AA_UseDesktopOpenGL QCoreApplication::setAttribute(Qt::AA_UseOpenGLES); //QCoreApplication::setAttribute(Qt::AA_UseSoftwareOpenGL);#endif QApplication a(argc, argv); 另外一个方法解决 全屏 + QWebEngineView 控件一起会产生右键菜单无法弹出的bug,需要上移一个像素 1234QRect rect = qApp-&gt;desktop()-&gt;geometry();rect.setY(-1);rect.setHeight(rect.height());this-&gt;setGeometry(rect); QStyle 内置了很多方法用处很大，比如精确获取滑动条鼠标按下处的值。 1QStyle::sliderValueFromPosition(minimum(), maximum(), event-&gt;x(), width()); 用 QFile 读写文件的时候，推荐用 QTextStream 文件流的方式来读写文件，速度快很多，基本上会有30%的提升，文件越大性能区别越大。 123456789101112131415161718//从文件加载英文属性与中文属性对照表QFile file(&quot;:/propertyname.txt&quot;);if (file.open(QFile::ReadOnly)) &#123; //QTextStream方法读取速度至少快30%#if 0 while(!file.atEnd()) &#123; QString line = file.readLine(); appendName(line); &#125;#else QTextStream in(&amp;file); while (!in.atEnd()) &#123; QString line = in.readLine(); appendName(line); &#125;#endif file.close();&#125; 用 QFile.readAll() 读取 QSS 文件默认是ANSI格式，不支持 UTF8 ，如果在 QtCreator 中打开qss 文件来编辑保存，这样很可能导致 qss 加载以后没有效果。 123456789101112131415161718192021222324252627282930void frmMain::initStyle()&#123; //加载样式表 QString qss; //QFile file(&quot;:/qss/psblack.css&quot;); //QFile file(&quot;:/qss/flatwhite.css&quot;); QFile file(&quot;:/qss/lightblue.css&quot;); if (file.open(QFile::ReadOnly)) &#123;#if 1 //用QTextStream读取样式文件不用区分文件编码 带bom也行 QStringList list; QTextStream in(&amp;file); //in.setCodec(&quot;utf-8&quot;); while (!in.atEnd()) &#123; QString line; in &gt;&gt; line; list &lt;&lt; line; &#125; qss = list.join(&quot;\\n&quot;);#else //用readAll读取默认支持的是ANSI格式,如果不小心用creator打开编辑过了很可能打不开 qss = QLatin1String(file.readAll());#endif QString paletteColor = qss.mid(20, 7); qApp-&gt;setPalette(QPalette(QColor(paletteColor))); qApp-&gt;setStyleSheet(qss); file.close(); &#125;&#125; QString 内置了很多转换函数，比如可以调用 toDouble 转为 double 数据，但是当你转完并打印的时候你会发现精确少了，只剩下三位了，其实原始数据还是完整的精确度的，只是打印的时候优化成了三位，如果要保证完整的精确度，可以调用 qSetRealNumberPrecision 函数设置精确度位数即可。 1234QString s1, s2;s1 = &quot;666.5567124&quot;;s2.setNum(888.5632123, &#x27;f&#x27;, 7);qDebug() &lt;&lt; qSetRealNumberPrecision(10) &lt;&lt; s1.toDouble() &lt;&lt; s2.toDouble(); 用QScriptValueIterator解析数据的时候，会发现总是会多一个节点内容，并且内容为空，如果需要跳过则增加一行代码。 123456while (it.hasNext()) &#123; it.next(); if (it.flags() &amp; QScriptValue::SkipInEnumeration) continue; qDebug() &lt;&lt; it.name();&#125; Qt 表格控件一些常用的设置封装，QTableWidget 继承自 QTableView ，所以下面这个函数支持传入 QTableWidget 。 1234567891011121314151617181920212223242526272829303132333435void QUIHelper::initTableView(QTableView *tableView, int rowHeight, bool headVisible, bool edit)&#123; //奇数偶数行颜色交替 tableView-&gt;setAlternatingRowColors(false); //垂直表头是否可见 tableView-&gt;verticalHeader()-&gt;setVisible(headVisible); //选中一行表头是否加粗 tableView-&gt;horizontalHeader()-&gt;setHighlightSections(false); //最后一行拉伸填充 tableView-&gt;horizontalHeader()-&gt;setStretchLastSection(true); //行标题最小宽度尺寸 tableView-&gt;horizontalHeader()-&gt;setMinimumSectionSize(0); //行标题最大高度 tableView-&gt;horizontalHeader()-&gt;setMaximumHeight(rowHeight); //默认行高 tableView-&gt;verticalHeader()-&gt;setDefaultSectionSize(rowHeight); //选中时一行整体选中 tableView-&gt;setSelectionBehavior(QAbstractItemView::SelectRows); //只允许选择单个 tableView-&gt;setSelectionMode(QAbstractItemView::SingleSelection); //表头不可单击#if (QT_VERSION &gt; QT_VERSION_CHECK(5,0,0)) tableView-&gt;horizontalHeader()-&gt;setSectionsClickable(false);#else tableView-&gt;horizontalHeader()-&gt;setClickable(false);#endif //鼠标按下即进入编辑模式 if (edit) &#123; tableView-&gt;setEditTriggers(QAbstractItemView::CurrentChanged | QAbstractItemView::DoubleClicked); &#125; else &#123; tableView-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers); &#125;&#125; 在一些大的项目中，可能嵌套了很多子项目，有时候会遇到子项目依赖其他子项目的时候，比如一部分子项目用来生成动态库，一部分子项目依赖这个动态库进行编译，此时就需要子项目按照顺序编译。 123456TEMPLATE = subdirs#设置ordered参数以后会依次编译 demo designer examplesCONFIG += orderedSUBDIRS += demoSUBDIRS += designerSUBDIRS += examples 很多时候用 QDialog 的时候会发现阻塞了消息，而有的时候我们希望是后台的一些消息继续运行不要终止，此时需要做个设置。 12QDialog dialog;dialog.setWindowModality(Qt::WindowModal); 在嵌入式 linux 上，如果设置了无边框窗体，而该窗体中又有文本框之类的，发现没法产生焦点进行输入，此时需要主动激活窗体才行。 123456//这种方式设置的无边框窗体在嵌入式设备上无法产生焦点setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::X11BypassWindowManagerHint);//需要在show以后主动激活窗体w-&gt;show();w-&gt;activateWindow(); 在不同的平台上文件路径的斜杠也是不一样的，比如 linux 系统一般都是 / 斜杠，而在windows上都是 \\\\ 两个反斜杠，Qt 本身程序内部无论在 win 还是 linux 都支持 / 斜杠的路径，但是一些第三方库的话可能需要转换成对应系统的路径，这就需要用到斜杠转换，Qt当然内置类方法。 1234567QString path = &quot;C:/temp/test.txt&quot;;path = QDir::toNativeSeparators(path);//输出 C:\\\\temp\\\\test.txtQString path = &quot;C:\\\\temp\\\\test.txt&quot;;path = QDir::toNativeSeparators(path);//输出 C:/temp/test.txt 二、其他经验 Qt 界的中文乱码问题，版本众多导致的如何选择安装包问题，如何打包发布程序的问题，堪称 Qt 界的三座大山！ 在Qt的学习过程中，学会查看对应类的头文件是一个好习惯，如果在该类的头文件没有找到对应的函数，可以去他的父类中找找，实在不行还有爷爷类，肯定能找到的。通过头文件你会发现很多函数接口其实 Qt 已经帮我们封装好了，有空还可以阅读下他的实现代码。 Qt 安装目录下的 Examples 目录下的例子，看完学完，月薪 20K 起步；Qt 常用类的头文件的函数看完学完使用一遍并加以融会贯通，月薪 30K 起步。 Qt在开发阶段不支持中文目录，切记，这是无数人可能犯的错误，在安装Qt集成开发环境以及编译器的时候，务必记得目录必须英文，否则很可能不正常，建议尽量用默认的安装位置。 如果出现崩溃和段错误，80%都是因为要么越界，要么未初始化，死扣这两点，80%的问题解决了。 Qt一共有几百个版本，关于如何选择Qt版本的问题，我一般保留四个版本，为了兼容 Qt4 用4.8.7，最后的支持XP的版本 5.7.0 ，最新的长期支持版本比如 5.12 ，最高的新版本比如5.14.2 。强烈不建议使用4.7以前和5.0到5.3之间的版本，太多bug和坑，稳定性和兼容性相比于之后的版本相当差，能换就换，不能换说服领导也要换。 Qt 和 msvc 编译器常见搭配是Qt5.7+VS2013、Qt5.9+VS2015、Qt5.12+VS2017，按照这些搭配来，基本上常用的模块都会有，比如 webengine 模块，如果选用的 Qt5.12+msvc2015，则很可能官方没有编译这个模块，只是编译了Qt5.12+msvc2017的。 终极秘籍：如果遇到问题搜索Qt方面找不到答案，试着将关键字用JAVA C# android打头，你会发现别有一番天地，其他人很可能做过！ 新版本Qt安装包安装的时候需要填写注册信息，如果不想填写，先禁用网卡，在运行安装包，可以直接跳过这一步进行安装。 最后一条：珍爱生命，远离编程。祝大家头发浓密，睡眠良好，情绪稳定，财富自由！ 三、学习资源推荐 名称 网址 QtWidget开源demo集合 https://gitee.com/feiyangqingyun/QWidgetDemo QtQuick/Qml开源demo集合 https://gitee.com/jaredtao/TaoQuick qtcn http://www.qtcn.org 豆子的空间 https://www.devbean.net yafeilinux http://www.qter.org 一去二三里 http://blog.csdn.net/liang19890820 乌托邦2号 http://blog.csdn.net/taiyang1987912 foruok http://blog.csdn.net/foruok jason http://blog.csdn.net/wsj18808050 朝十晚八 http://www.cnblogs.com/swarmbees BIG_C_GOD http://blog.csdn.net/big_c_god 公孙二狗 https://qtdebug.com/qtbook 雨田哥 https://blog.csdn.net/ly305750665 郑天佐 https://blog.csdn.net/zhengtianzuo06 寒山-居士 https://blog.csdn.net/esonpo feiyangqingyun https://blog.csdn.net/feiyangqingyun 前行中小猪 http://blog.csdn.net/goforwardtostep 涛哥的知乎专栏 https://zhuanlan.zhihu.com/TaoQt Qt君 https://blog.csdn.net/nicai_xiaoqinxi Qt老外视频教程 http://space.bilibili.com/2592237/#!/index Qt维基补充文档 https://wiki.qt.io/Main Qt源码查看网站 https://code.woboq.org/qt5 Qt官方下载地址 https://download.qt.io Qt官方下载新地址 https://download.qt.io/new_archive/qt/ Qt国内镜像下载地址 https://mirrors.cloud.tencent.com/qt Qt安装包下载地址 http://qthub.com/download/ (超过1000多个，由Qt君整理) 精美图表控件QWT http://qwt.sourceforge.net/ 精美图表控件QCustomPlot https://www.qcustomplot.com/ 免费图标下载 http://www.easyicon.net/ 图形字体下载 https://www.iconfont.cn/ 漂亮界面网站 https://www.ui.cn/ 四、其他 C++入门书籍推荐《C++ primer plus》，进阶书籍推荐《C++ primer》。 Qt入门书籍推荐霍亚飞的《Qt Creator快速入门》，Qt进阶书籍推荐官方的《C++ GUI Qt4编程》，qml书籍推荐《Qt5编程入门》。 强烈推荐程序员自我修养和规划系列书《大话程序员》《程序员的成长课》《解忧程序员》，受益匪浅，受益终生！","categories":[{"name":"知识整理","slug":"知识整理","permalink":"https://blog.amoswu.top/categories/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"}],"tags":[{"name":"2020","slug":"2020","permalink":"https://blog.amoswu.top/tags/2020/"},{"name":"转载","slug":"转载","permalink":"https://blog.amoswu.top/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"Qt","slug":"Qt","permalink":"https://blog.amoswu.top/tags/Qt/"},{"name":"C++","slug":"C","permalink":"https://blog.amoswu.top/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.amoswu.top/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Qt 动态链接库","slug":"Qt 动态链接库","date":"2020-09-01T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"17b0.html","link":"","permalink":"https://blog.amoswu.top/17b0.html","excerpt":"","text":"近期，在学完 Qt 编程的一些基础知识后，我逐渐往更深层次进发。今天，要记录的是，Qt 框架中动态链接库相关的知识。 有动态链接库是就会有静态链接库，来都来了，肯定是要一次性都解决的。先来看看这两类链接库的区别。 静态链接库（Static-link library）就是把要调用的函数或者过程链接到可执行文件中，成为可执行文件的一部分的库。换言之，函数和过程的代码就在主程序的 .exe 文件中，该文件包含了运行时所需的全部代码。当多个程序调用相同的函数是，内存中会存在这个函数的多个拷贝。在 Windows 操作系统中，静态链接库对应的后缀名为 .lib, 在 Linux 操作系统中，静态链接库对应的后缀名为 .a 。 动态链接库（Dynamic-link library）是微软公司在 Windows 操作系统中实现共享库概念的一种实现方式，后被很多操作系统作为参考，从而使其有了更大的发展。在 Windows 操作系统中，静态链接库对应的后缀名为 .dll , 在 Linux 操作系统中，动态链接库对应的后缀名为 .so。 在 Windows 操作戏台中，所谓动态链接，就是把一些经常会共享的代码（静态链接的 OBJ 程序库）制作成 DLL 档，当可执行文件调用到 DLL 档内的函数时， Windows 操作系统才会把 DLL 档加载到内存中， DLL 档本身的结构就是可执行档，当程序有需求时函数才进行链接。一般情况下，如果一个应用使用了动态链接库， Win32 系统保证内存中只有DLL的一份复制品。 说完动态链接库与静态链接库的区别，不能光纸上谈兵，应该动手来个实例。不如就动手实现一个简易计算的动态库吧。 编写动态库1.建立库文件首先打开 Qt Creator 的新建对话窗口，找到 Library，点击创建 C++ Library。 给定一个名字，然后点击下一步 ，在选择 Qt module 时，选择 Core模块。 接着，勾选一个编译环境。 2. 编写库函数代码compute.pro 1234567891011121314151617181920QT -= guiTEMPLATE = libDEFINES += COMPUTE_LIBRARYCONFIG += c++11DEFINES += QT_DEPRECATED_WARNINGSSOURCES += \\ compute.cppHEADERS += \\ compute_global.h \\ compute.hunix &#123; target.path = /usr/lib&#125;!isEmpty(target.path): INSTALLS += target compute.h 1234567891011121314151617181920212223242526/*************************************************** * * @file compute.h * @version 1.0 * * @author AmosWu * @date 2020/09/02 * @history ***************************************************/#ifndef COMPUTE_H#define COMPUTE_H#include &quot;compute_global.h&quot;class COMPUTE_EXPORT Compute&#123;public: Compute(); int sum(int x, int y); int diff(int x, int y); double prod(double a, double b); double divi(double a, double b);&#125;;#endif // COMPUTE_H compute_global.h 123456789101112#ifndef COMPUTE_GLOBAL_H#define COMPUTE_GLOBAL_H#include &lt;QtCore/qglobal.h&gt;#if defined(COMPUTE_LIBRARY)# define COMPUTE_EXPORT Q_DECL_EXPORT#else# define COMPUTE_EXPORT Q_DECL_IMPORT#endif#endif // COMPUTE_GLOBAL_H compute.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041/*************************************************** * * @file compute.cpp * @version 1.0 * * @author AmosWu * @date 2020/09/02 * @history ***************************************************/#include &quot;compute.h&quot;Compute::Compute()&#123;&#125;int Compute::sum(int x, int y)&#123; return x + y;&#125;int Compute::diff(int x, int y)&#123; return x - y;&#125;double Compute::prod(double a, double b)&#123; return a * b;&#125;double Compute::divi(double a, double b)&#123; if(b &gt; 0) &#123; return a / b; &#125; else &#123; return 999.99; &#125;&#125; 在编写完上述代码后，我们调试一下，或者构建不运行，就会在对应文件夹看到已经生成 .lib 和 .dll等库文件了。 调用动态库1.创建项目这里就不再赘述了了了了了了了了了了 2.拷贝头文件将头文件拷贝到应用工程的目录下，对于大型项目要单独建立文件夹，这里是一个小 Demo ，我就直接放到根目录下了。 3. 引入dll.pro 1LIBS += ‪-LE:/Qt_code/build-compute-Desktop_Qt_5_14_0_MinGW_64_bit-Debug/compute.dll main.cpp 1234567891011121314151617#include &quot;widget.h&quot;#include &quot;compute.h&quot;#include &lt;QApplication&gt;#include &lt;QDebug&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); Widget w; w.setWindowTitle(QStringLiteral(&quot;简易计算器&quot;)); Compute cal; qDebug() &lt;&lt; &quot;Result:&quot; &lt;&lt; cal.sum(2, 10) &lt;&lt; endl; w.show(); return a.exec();&#125; 4.拷贝 .dll 到编译好的程序 .exe 同级目录下 5. 调试运行 此篇仅做动态链接库知识基础，还有更多高级应用，请移步搜索引擎~","categories":[{"name":"新知","slug":"新知","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/"},{"name":"笔记","slug":"新知/笔记","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"2020","slug":"2020","permalink":"https://blog.amoswu.top/tags/2020/"},{"name":"Qt","slug":"Qt","permalink":"https://blog.amoswu.top/tags/Qt/"},{"name":"C++","slug":"C","permalink":"https://blog.amoswu.top/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.amoswu.top/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Qt 流读写XML","slug":"Qt 流读写XML","date":"2020-08-30T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"cbea.html","link":"","permalink":"https://blog.amoswu.top/cbea.html","excerpt":"","text":"最近在学习 Qt 读写XML文件时，思考了一个问题，除了DOM和SAX外，还有没有更快捷的读写XML的方法？经过一番面向搜索引擎编程，我还真发现了一种方法——流读写XML(Write and read by stream)。今天就借此文向大家分享一下这种方法。 三种读写XML方式的对比 DOM方式 SAX方式 流读写方式 XML被存入内存 速度快，逐行扫描 速度快，一次性传入 消耗内存较多 操作复杂，很难修改 不支持修改和删除 频繁操作较为方便 可以随时停止解析，对大型文档友好 读写API分离 看完对比，你是不是跃跃欲试了？下面我贴上我的练习代码，给你作为参考。 *.pro 123456789101112131415161718192021QT += core gui xmlgreaterThan(QT_MAJOR_VERSION, 4): QT += widgetsCONFIG += c++11DEFINES += QT_DEPRECATED_WARNINGSSOURCES += \\ main.cpp \\ widget.cppHEADERS += \\ widget.hFORMS += \\ widget.uiqnx: target.path = /tmp/$$&#123;TARGET&#125;/binelse: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin!isEmpty(target.path): INSTALLS += target widget.h 123456789101112131415161718192021222324252627282930313233343536373839#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;QT_BEGIN_NAMESPACEnamespace Ui&#123;class Widget;&#125;QT_END_NAMESPACEclass Widget : public QWidget&#123; Q_OBJECTpublic: Widget(QWidget *parent = nullptr); ~Widget(); /* Func : write_xml() * Feat : 将数据写入XML文件并将写入结果在控制台打印 * Auth : AmosWu * Date : 2020/08/30 * vers : 1.0 */ int write_xml(); /* Func : read_xml() * Feat : 将数据从XML文件读取出来并在控制台打印 * Auth : AmosWu * Date : 2020/08/30 * vers : 1.0 */ int read_xml();private: Ui::Widget *ui;&#125;;#endif // WIDGET_H main.cpp 1234567891011121314#include &quot;widget.h&quot;#include &lt;QApplication&gt;#include &lt;QFile&gt;#include &lt;QXmlStreamWriter&gt;#include &lt;QXmlReader&gt;#include &lt;QtDebug&gt;#include &lt;QStringList&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); Widget(); return a.exec();&#125; widget.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173/* Name : widget.cpp * Date : 2020/08/30 * Auth : Amos */#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;#include &lt;QFile&gt;#include &lt;QXmlStreamWriter&gt;#include &lt;QtDebug&gt;#include &lt;QStringList&gt;Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); int resWrite = write_xml(); if (resWrite &lt; 0) &#123; qDebug() &lt;&lt; &quot;ERRO : Write failed!&quot;; &#125; else &#123; qDebug() &lt;&lt; &quot;INFO : Write succeed!&quot;; &#125; int resRead = read_xml(); if(resRead &lt; 0) &#123; qDebug() &lt;&lt; &quot;ERRO : Read failed!&quot;; &#125; else &#123; qDebug() &lt;&lt; &quot;INFO : Read succeed!&quot;; &#125;&#125;Widget::~Widget()&#123; delete ui;&#125;int Widget::write_xml()&#123; QStringList urls_list; QStringList name_list; QStringList stockList; urls_list &lt;&lt; &quot;https://cn.bing.com&quot; &lt;&lt; &quot;https://google.com&quot; &lt;&lt; &quot;https://baidu.com&quot; &lt;&lt; &quot;https://sougou.com&quot; &lt;&lt; &quot;https://mi.com&quot;; name_list &lt;&lt; &quot;Bing&quot; &lt;&lt; &quot;Google&quot; &lt;&lt; &quot;Baidu&quot; &lt;&lt; &quot;Sougou&quot; &lt;&lt; &quot;Xiaomi&quot;; stockList &lt;&lt; &quot;MSFT.US&quot; &lt;&lt; &quot;GOOG.US&quot; &lt;&lt; &quot;BIDU.US&quot; &lt;&lt; &quot;SOGO.US&quot; &lt;&lt; &quot;01810.HK&quot;; // url_list.append(&quot;https://cn.bing.com&quot;); QFile file(&quot;test.xml&quot;); if (!file.open(QFile::WriteOnly | QFile::Text)) &#123; qDebug() &lt;&lt; QString(&quot;ERRO : Connot open file test.xml(%2)&quot;) .arg(file.errorString()); return -1; &#125; QXmlStreamWriter stream(&amp;file); stream.setCodec(&quot;UTF-8&quot;); // XML编码 stream.setAutoFormatting(true); // 自动格式化 stream.writeStartDocument(&quot;1.0&quot;, true); // 开始文档（XML声明） stream.writeStartElement(&quot;compangy&quot;); // 创建根节点 for(int i = 0; i &lt; urls_list.size(); i++) &#123; stream.writeStartElement(&quot;tech&quot;); stream.writeAttribute(&quot;name&quot;, name_list.at(i)); stream.writeAttribute(&quot;url&quot;, urls_list.at(i)); stream.writeTextElement(&quot;stock_code&quot;, stockList.at(i)); stream.writeEndElement(); qDebug() &lt;&lt; QString(&quot;[ %1-%2 ] write succeed!&quot;) .arg(name_list.at(i)) .arg(urls_list.at(i)); &#125; stream.writeEndElement(); stream.writeEndDocument(); file.close(); return 1;&#125;int Widget::read_xml()&#123; QString strFile(&quot;test.xml&quot;); QFile file(strFile); if(!file.open(QFile::ReadOnly | QFile::Text)) &#123; qDebug() &lt;&lt; QString(&quot;ERRO : Connot open file %1(%2)&quot;) .arg(strFile) .arg(file.errorString()); return -1; &#125; // 如果读取到文档结尾，并且没有出现错误 QXmlStreamReader reader(&amp;file); reader.readNext(); // 跳过根节点 while(!reader.atEnd()) &#123; // 读取下一个记号，它返回记号的类型 QXmlStreamReader::TokenType nType = reader.readNext(); // 下面根据记号的类型来进行不同的输出 // 读取文档的编码方式和版本号 if(nType == QXmlStreamReader::StartDocument) &#123; qDebug() &lt;&lt; &quot;DocEncoding = &quot; &lt;&lt; reader.documentEncoding() &lt;&lt; &quot;DocVersion = &quot; &lt;&lt; reader.documentVersion(); &#125; if(reader.isStartElement()) &#123; if(reader.name() == &quot;tech&quot;) &#123; qDebug() &lt;&lt; &quot;&lt;&quot; &lt;&lt; reader.name() &lt;&lt; &quot;&gt;&quot;; if (reader.attributes().hasAttribute(&quot;name&quot;)) qDebug() &lt;&lt; reader.attributes() .value(&quot;name&quot;); if (reader.attributes().hasAttribute(&quot;url&quot;)) qDebug() &lt;&lt; reader.attributes() .value(&quot;url&quot;); reader.readNext(); &#125; else if(reader.name() == &quot;stock_code&quot;) &#123; qDebug() &lt;&lt; &quot;&lt;&quot; &lt;&lt; reader.name() &lt;&lt; &quot;&gt;&quot;; qDebug() &lt;&lt; reader.readElementText(); reader.readNext(); &#125; else &#123; reader.readNext(); &#125; if (nType == QXmlStreamReader::EndElement) qDebug() &lt;&lt; &quot;&lt;/&quot; &lt;&lt; reader.name() &lt;&lt; &quot;&gt;&quot;; // 打印字符 if(nType == QXmlStreamReader::Characters &amp;&amp; !reader.isWhitespace()) qDebug() &lt;&lt; reader.text(); &#125; &#125; // 如果读取过程中出现错误，那么输出错误信息 if(reader.hasError()) &#123; qDebug() &lt;&lt; &quot;ERRO : &quot; &lt;&lt; reader.errorString(); return -1; &#125; file.close(); return 1;&#125; test.xml 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;compangy&gt; &lt;tech name=&quot;Bing&quot; url=&quot;https://cn.bing.com&quot;&gt; &lt;stock_code&gt;MSFT.US&lt;/stock_code&gt; &lt;/tech&gt; &lt;tech name=&quot;Google&quot; url=&quot;https://google.com&quot;&gt; &lt;stock_code&gt;GOOG.US&lt;/stock_code&gt; &lt;/tech&gt; &lt;tech name=&quot;Baidu&quot; url=&quot;https://baidu.com&quot;&gt; &lt;stock_code&gt;BIDU.US&lt;/stock_code&gt; &lt;/tech&gt; &lt;tech name=&quot;Sougou&quot; url=&quot;https://sougou.com&quot;&gt; &lt;stock_code&gt;SOGO.US&lt;/stock_code&gt; &lt;/tech&gt; &lt;tech name=&quot;Xiaomi&quot; url=&quot;https://mi.com&quot;&gt; &lt;stock_code&gt;01810.HK&lt;/stock_code&gt; &lt;/tech&gt;&lt;/compangy&gt; 在学习这种读写方式时，我也踩了一些坑。 XML有且只有一个根节点。 良好的方法封装有利于降低代码（模块）间的耦合； 错误信息输出、注释在新学习时必不可少； 好了，本期的分享就到此为止了。如果对你有启发，欢迎转载~","categories":[{"name":"新知","slug":"新知","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/"},{"name":"笔记","slug":"新知/笔记","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"2020","slug":"2020","permalink":"https://blog.amoswu.top/tags/2020/"},{"name":"Qt","slug":"Qt","permalink":"https://blog.amoswu.top/tags/Qt/"},{"name":"C++","slug":"C","permalink":"https://blog.amoswu.top/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.amoswu.top/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Qt C++ MSVC 编译环境构建","slug":"Qt C++ MSVC 编译环境构建","date":"2020-08-19T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"b30a.html","link":"","permalink":"https://blog.amoswu.top/b30a.html","excerpt":"","text":"近期在Qt环境下编写C++代码时，我发现如果不安装 Visual Stadio 全家桶的话无法进行 MSVC编译。而我所面临的问题是，放在公司的这台笔记本存储空间只有128GB。对，你没有看错，是128G，而且是整个电脑。安装之前我忘记截图了，这里就po一张按照本文配置完后的磁盘截图。 当时，我就产生了一个想法，难道微软这么大的厂，不安装它的全家桶不至于让我们编译不了吧。在经过一番搜索之后，我发现了一个非常棒的解决方案。经过我一个多小时的测试，非常有效！！！ 废话不多说了，上干货。 OS version Windows10 Pro 64bit Qt version 5.14.0 Qt creator 4.11.0 MSVC version 2017 一、原理解析我们都知道，如果你安装了Visual Stadio全家桶，在Qt Creator里可以自动检测到MSVC的编译环境。为什么Qt能自动检测出MSVC环境呢？经过一番研究和搜集，我发现，在安装Visual Stadio过程中，Visual Stadio自动对Qt的环境做了适配。 这种适配，主要是通过修改注册表中某一个项来实现的。大致过程是这样的，在安装完Visual Stadio后，它自动修改了注册表，当你再打开Qt Creator时，Qt Creator会自动去查找这个注册表是否有变化，如果发生了变化，就自动适配变化后的编译器，否则，就不做任何修改。 究竟是哪个注册表让这种神奇的现象发生的呢？ Win 32bit环境下： HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\VisualStuidio\\SxS\\VS7 Win 64bit环境下：HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\VisualStuidio\\SxS\\VS7 Qt Creator会遍历SxS文件夹下的每一个项来比对注册表的变化。 如果键名（其实就是数字）大于 14（从 15 开始，即 msvc2017，那就把该键值（其实就是硬盘里的 vs 安装路径）后面拼接上 /VC/Auxiliary/Build 查看此处是不是有 vcvarsall.bat 文件。 否则（即键名小于等于 14），那就把该键值后面拼接上 /VC7 查看此处是不是有 vcvarsall.bat 文件。 上述的数值与MSVC版本的对应关系可以参考： https://www.cnblogs.com/zjutzz/p/6013783.html https://docs.microsoft.com/zh-cn/visualstudio/releases/2019/release-notes 正常情况下修改好这些注册表的键值，就能达到在Qt Creator使用MSVC编译代码的效果，除非你的电脑中找不到vcvarsall.bat文件。 二、详细操作步骤1.前期准备a.存储空间准备 安装好Qt Creator的前提下，至少预留10GB的磁盘空间。 没有安装Qt Creator的前提下，至少预留20GB的磁盘空间。 b.工具准备 Visual Stadio 2019 生成工具 下载地址：https://visualstudio.microsoft.com/zh-hans/downloads/ qt-opensource-windows-x86-5.12.4.exe （已安装请忽略） 下载地址：https://mirrors.tuna.tsinghua.edu.cn/qt/official_releases/qt/5.12/5.12.4/ 2.安装工具篇幅所限，安装 Qt 的步骤在这里就省略了。 Visual Stadio 2019 生成工具的安装 打开已经下载好的安装包，第一次打开需要下载一些包文件，下载速度视网速决定，请耐心等待。 进入界面后，只需勾选C++生成工具，在右侧的安装详细信息菜单中再继续勾选你需要的工具。 Tips：Qt 5.14 推荐采用 MSVC 2017，下图右侧也有 2017的可选项，但是该工具默认链接的是2019版，并且也能正常使用，所以就先不折腾了，保持默认，只勾图中左侧一个勾，右侧会自动勾选默认的几个选项。 然后就耐心等待联网下载和安装。 等安装完毕，就可以关闭这个页面了。 3.增加Qt Creator组件如果你和我一样，在配置之前，已经安装完Qt Creator了，那请你继续看这一段。 打开Qt Creator安装目录 打开MaintenanceTool.exe 单击右下角设置，再单击资料档案库，添加临时资料档案库，地址是http://mirrors.ustc.edu.cn/qtproject/online/qtsdkrepository/windows_x86/root/qt/ Ps : 这里有个大坑，必须说一下，下载元信息响应会很慢，稍等10分钟左右就可以了。 选择要添加的组件 4.环境配置【重要！！！】如果这时候你直接打开Qt Creator，你会发现编程器里面还是空的。别着急，要想让自动Qt Creator 检测刚刚安好的编译器，还有关键一步。 关闭 Qt Creator； 按下 Windows + R 在弹出的窗口输入regedit，打开注册表编辑器； 打开后，在输入框粘贴下方的路径 \\HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\VisualStudio 右击，新建 -&gt; 项 ，连续新建两项，注意层次关系和大小写。 在 VS7 上新建字符串值，名称是16.0，值是 vs生成工具的安装目录下的一个子目录，具体看图中3处和横线处（仔细看图，我没写错），要保证横线处的路径下有红色箭头处的文件。 至此，再打开 Qt Creator 会发现已经自动识别编译环境并且添加好了。 当你兴奋地去新建一个测试程序时，你会发现一个新问题，这个编译环境不能单步调试。这是因为当前 Qt 无法调用 cdb.exe所致。下面我们手动为 Qt 与 cdb 工具建立链接。 1. 打开控制面板 依次找到 程序 -&gt; 程序和功能 ，右击截图中的 Windows SDK ，选择 更改。 选择 Change 勾选图中的选项。 再次重启，Qt Creator ，你会发现 Debugger下拉框里已经探测到 cdb 了。 参考文章： 正确在 Windows 上配置 MSVC(2019) 作为 Qt 编译器","categories":[{"name":"新知","slug":"新知","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/"},{"name":"笔记","slug":"新知/笔记","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"2020","slug":"2020","permalink":"https://blog.amoswu.top/tags/2020/"},{"name":"Qt","slug":"Qt","permalink":"https://blog.amoswu.top/tags/Qt/"},{"name":"C++","slug":"C","permalink":"https://blog.amoswu.top/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.amoswu.top/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Qt C++ 对XML的增删改查","slug":"Qt C++ 对XML的增删改查","date":"2020-08-13T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"97ec.html","link":"","permalink":"https://blog.amoswu.top/97ec.html","excerpt":"","text":"最近，学习了Qt C++对XML的一系列操作。今天，把相关代码和注释贴在这里， 以备后续使用。 什么是 XML 可扩展标记语言（英语：Extensible Markup Language，简称：XML）是一种标记语言。标记指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种信息的文章等。 ——from Wikipedia Qt 如何操作 XML.pro 文件增加 QT += xml模块。 .cpp 文件头部 #include &lt;QtXml&gt; 写入 XML源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void Widget::write_xml()&#123; // 打开或创建文件 QFile file(&quot;test.xml&quot;); //相对路径、绝对路径、资源路径都可以 if(!file.open(QFile::WriteOnly | QFile::Truncate)) return; QDomDocument doc; // 写入XML头部 QDomProcessingInstruction instruction;//添加处理命令 instruction = doc.createProcessingInstruction(&quot;xml&quot;, &quot;version=\\&quot;1.0\\&quot; encoding=\\&quot;UTF-8\\&quot;&quot;); doc.appendChild(instruction); // 添加根节点 QDomElement root = doc.createElement(&quot;library&quot;); doc.appendChild(root); // 添加第一个子节点及其元素 QDomElement book = doc.createElement(&quot;book&quot;); book.setAttribute(&quot;id&quot;, 1); // 方式一：创建属性 其中键值对的值可以是各种类型 QDomAttr time = doc.createAttribute(&quot;time&quot;); time.setValue(&quot;2020/08/11&quot;); // 方式二：创建属性 值必须是字符串 book.setAttributeNode(time); QDomElement title = doc.createElement(&quot;title&quot;); // 创建子元素 QDomText text; // 设置括号标签中间的值 text = doc.createTextNode(&quot;C++ primer&quot;); book.appendChild(title); title.appendChild(text); QDomElement author = doc.createElement(&quot;author&quot;); // 创建子元素 text = doc.createTextNode(&quot;Stanley Lippman&quot;); author.appendChild(text); book.appendChild(author); root.appendChild(book); QDomElement price = doc.createElement(&quot;price&quot;); text = doc.createTextNode(&quot;$29.9&quot;); price.appendChild(text); book.appendChild(price); root.appendChild(book); // 添加第二个子节点及其子元素，部分变量只需重新赋值 book = doc.createElement(&quot;book&quot;); book.setAttribute(&quot;id&quot;, 2); time = doc.createAttribute(&quot;time&quot;); time.setValue(&quot;2020/08/10&quot;); book.setAttributeNode(time); title = doc.createElement(&quot;title&quot;); text = doc.createTextNode(&quot;Thinking in Java&quot;); book.appendChild(title); title.appendChild(text); author = doc.createElement(&quot;author&quot;); text = doc.createTextNode(&quot;Bruce Eckel&quot;); author.appendChild(text); book.appendChild(author); root.appendChild(book); // 输出到文件 QTextStream out_stream(&amp;file); doc.save(out_stream, 4); // 缩进4格 file.close();&#125; 调试结果 test.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;library&gt; &lt;book time=&quot;2020/08/11&quot; id=&quot;1&quot;&gt; &lt;title&gt;C++ primer&lt;/title&gt; &lt;author&gt;Stanley Lippman&lt;/author&gt; &lt;price&gt;$29.9&lt;/price&gt; &lt;/book&gt; &lt;book time=&quot;2020/08/10&quot; id=&quot;2&quot;&gt; &lt;title&gt;Thinking in Java&lt;/title&gt; &lt;author&gt;Bruce Eckel&lt;/author&gt; &lt;/book&gt;&lt;/library&gt; 读取 XML源代码 123456789101112131415161718192021222324252627282930313233343536373839404142void Widget::read_xml()&#123; // 打开或创建文件 QFile file(&quot;test.xml&quot;); // 相对路径、绝对路径、资源路径 if(!file.open(QFile::ReadOnly)) &#123; return; &#125; QDomDocument doc; if(!doc.setContent(&amp;file)) &#123; file.close(); return; &#125; file.close(); QDomElement root = doc.documentElement(); // 返回根节点 qDebug() &lt;&lt; root.nodeName(); QDomNode node = root.firstChild(); while(!node.isNull()) // 如果节点不空 &#123; if(node.isElement()) &#123; // 转换为元素，注意元素和节点是两个数据结构 QDomElement e = node.toElement(); // 打印键值对，tagName和nodeName是一个东西 qDebug() &lt;&lt; e.tagName() &lt;&lt; &quot; &quot; &lt;&lt; e.attribute(&quot;id&quot;) &lt;&lt; &quot; &quot; &lt;&lt; e.attribute(&quot;time&quot;); QDomNodeList list = e.childNodes(); // 遍历子元素，count和size都可以使用，可用于标签数计数 for (int i = 0; i &lt; list.count(); i++) &#123; QDomNode n = list.at(i); if(node.isElement()) &#123; qDebug() &lt;&lt; n.nodeName() &lt;&lt; &quot;:&quot; &lt;&lt; n.toElement().text(); &#125; &#125; &#125; node = node.nextSibling(); &#125;&#125; 增加 XML 内容源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 增加XML内容void Widget::add_xml()&#123; // 打开文件 QFile file(&quot;test.xml&quot;); // 相对路径、绝对路径、资源路径都可以 if(!file.open(QFile::ReadOnly)) &#123; return; &#125; // 增加一个以及子节点以及元素 QDomDocument doc; if(!doc.setContent(&amp;file)) &#123; file.close(); return; &#125; file.close(); QDomElement root = doc.documentElement(); QDomElement book = doc.createElement(&quot;book&quot;); book.setAttribute(&quot;id&quot;, 3); book.setAttribute(&quot;time&quot;, &quot;1999/09/09&quot;); QDomElement title = doc.createElement(&quot;title&quot;); QDomText text; text = doc.createTextNode(&quot;Pride and Prejudice&quot;); title.appendChild(text); book.appendChild(title); QDomElement author = doc.createElement(&quot;author&quot;); text = doc.createTextNode(&quot;Jane Austen&quot;); author.appendChild(text); book.appendChild(author); QDomElement price = doc.createElement(&quot;price&quot;); text = doc.createTextNode(&quot;$69.9&quot;); price.appendChild(text); book.appendChild(price); root.appendChild(book); if(!file.open(QFile::WriteOnly | QFile::Truncate)) &#123; // 先读进来，再重写 ，如果不用truncate就是在后面追加内容 return; &#125; // 输出到文件 QTextStream out_stream(&amp;file); doc.save(out_stream, 4); // 缩进4格 file.close();&#125; 删除 XML 内容源代码 1234567891011121314151617181920212223242526272829303132333435363738394041// 删除XML内容void Widget::remove_xml()&#123; // 打开文件 QFile file(&quot;test.xml&quot;); // 相对路径、绝对路径、资源路径都可以 if(!file.open(QFile::ReadOnly)) &#123; return; &#125; // 删除一个一级子节点及其元素，外层节点删除内层节点与此相同 QDomDocument doc; if(!doc.setContent(&amp;file)) &#123; file.close(); return; &#125; file.close(); // 一定要记得关闭，不然无法完成操作 QDomElement root = doc.documentElement(); QDomNodeList list = doc.elementsByTagName(&quot;book&quot;); // 由标签名定位 for(int i = 0; i &lt; list.count(); i++) &#123; QDomElement e = list.at(i).toElement(); if(e.attribute(&quot;time&quot;) == &quot;2020/08/09&quot;) // 以属性名定位，类似于hash方式 &#123; root.removeChild(list.at(i)); // 这里仅删除一个节点，可以加入break break; &#125; &#125; if(!file.open(QFile::WriteOnly | QFile::Truncate)) &#123; return; &#125; // 输出到文件 QTextStream out_stream(&amp;file); doc.save(out_stream, 4); file.close();&#125; 更新 XML 内容源代码 12345678910111213141516171819202122232425262728293031323334353637// 更新XML内容void Widget::update_xml()&#123; // 打开文件 QFile file(&quot;test.xml&quot;); if(!file.open(QFile::ReadOnly)) &#123; return; &#125; //更新一个标签项，如果知道XML的结构，直接定位到那个标签定点更新 //或者用遍历的方法去匹配tagname或者attribute，value来更新 QDomDocument doc; if(!doc.setContent(&amp;file)) &#123; file.close(); return; &#125; file.close(); QDomElement root = doc.documentElement(); QDomNodeList list = root.elementsByTagName(&quot;book&quot;); QDomNode node = list.at(list.size() - 1).firstChild(); // 定位到第三格以及子节点的子元素 QDomNode oldnode = node.firstChild(); // 标签之间的内容作为节点的子节点出现，当前是 How to learn Python node.firstChild().setNodeValue(&quot;Update_success&quot;); QDomNode newnode = node.firstChild(); node.replaceChild(newnode, oldnode); if(!file.open(QFile::WriteOnly | QFile::Truncate)) &#123; return; &#125; // 输出到文件 QTextStream out_stream(&amp;file); doc.save(out_stream, 4); // 缩进4格 file.close();&#125; 今天的分享就到这里，后续我会继续更新我的Qt学习记录~","categories":[{"name":"新知","slug":"新知","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/"},{"name":"笔记","slug":"新知/笔记","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"2020","slug":"2020","permalink":"https://blog.amoswu.top/tags/2020/"},{"name":"Qt","slug":"Qt","permalink":"https://blog.amoswu.top/tags/Qt/"},{"name":"C++","slug":"C","permalink":"https://blog.amoswu.top/tags/C/"},{"name":"教程","slug":"教程","permalink":"https://blog.amoswu.top/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Qt Creator 编辑器下的代码格式化","slug":"Qt Creator编辑器下的代码格式化","date":"2020-08-10T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"48d2.html","link":"","permalink":"https://blog.amoswu.top/48d2.html","excerpt":"","text":"对于习惯使用VsCode、SublimeText、JetBrains 全家桶等编译器的开发人员来说，一键格式化代码是必不可少的功能。最近，我在进行Qt C++开发时发现，Qt Creator默认没有一键格式化代码相关的配置。经过几小时的面向搜索引擎解决问题后，我发现了一个可行的解决方案，今天在这里分享给大家。 大致的思路是可以以简单描述为：配置Beautifier:arrow_right:下载Artistic Style:arrow_right:配置 Artistic Style:arrow_right:设置快捷键。 下面我详细展开每个步骤，一一讲解。 本文只针对Windows操作系统下的配置进行验证，其他操作系统请自行搜索相关教程。 1.配置 Beautifier打开Qt Creator，依次点击菜单栏的帮助、关于插件。 展开C++选项卡，找到Beautifier(experimental)，勾选Load打开Beautifier。 此时，系统会提示重启Qt Creator后生效，我们立刻重启编辑器。 重启后，我们需要检查是否已开启 Beautifier，依次点击菜单栏的工具、选项。 如下图所示，在左侧有Beautifier选项卡时，说明开启成功。 2.下载 Artistic Style这里有两个下载源， 1）https://sourceforge.net/projects/astyle/files/ –来自官方（不推荐，下载速度较慢） 2）https://amos.lanzous.com/iXURDfi7zgb –本人上传（推荐，解压密码：as2020） 3.配置 Artistic Style下载完成并解压，将解压后的文件夹放到非中文路径下，接着打开上一张图片所示的选项窗口，点击Beautifier。 点击General选项卡，可根据自己的需求决定是否勾选 Enable auto format on file save（当文件被保存时自动格式化）。 在Tool栏选择Artistic Style，下面两项：Restrict to MIME Types和 Restrict to files contained in current project可以根据自己的需要自由选择。 点击 Artistic Style选项卡，在 Artistic Style command 选项中，点击浏览选择打开刚刚下载并解压好的 Artistic Style文件夹，再打开bin文件夹，找到AStyle.exe,点击打开，看到显示字色变成白色，说明打开成功。 继续给AStyle增加格式化代码的配置，这里提供了四个选项， .astylerc defined in project files 表示使用在项目文件 pro 中，定义 DISTFILES 中的任意 .astylerc 文件选项； Use specific config file 表示使用特定的某个配置选项文件； Use file .astylerc or astylerc in HOME或APPDATA 表示使用环境变量HOME（Linux）目录中的 .astylerc 选项文件，或者APPDATA（Windows）目录中的 astylerc 选项文件； Use customized style 表示使用用户自定义的选项配置（内容与astylerc文件相同）。 这里我选用的是第四个选项，自定义配置。这种配置方式相对简单，因为Artistic Style 本身提供了一些代码格式化的风格。 依次点击Add、输入自定义的一个名称、输入配置值，我这里选用的是GNU风格，Artistic Style 自带了15种配置风格。 这里介绍几种常见的代码风格，更多的代码风格请参考官方帮助文档。 allman风格 12345678910int Foo(bool isBar)&#123; if (isBar) &#123; bar(); return 1; &#125; else return 0;&#125; java风格 1234567int Foo(bool isBar)&#123; if (isBar)&#123; bar(); return 1; &#125;else return 0;&#125; kr风格 12345678int Foo(bool isBar)&#123; if (isBar)&#123; bar(); return 1; &#125;else return 0;&#125; gnu风格 12345678910int Foo(bool isBar)&#123; if (isBar) &#123; bar(); return 1; &#125; else return 0;&#125; linux风格 12345678int Foo(bool isBar)&#123; if (isFoo) &#123; bar(); return 1; &#125; else return 0;&#125; google风格 1234567int Foo(bool isBar) &#123; if (isBar) &#123; bar(); return 1; &#125; else return 0;&#125; 4.设置快捷键依次点击菜单栏工具、环境、键盘，找到FormatFile，然后点击Record录制自己的快捷键，最后点击Appply。 到这儿，我们Qt 环境配置的教程就结束了，后续我会继续带来Qt学习的相关笔记、想法和其他干货~","categories":[{"name":"新知","slug":"新知","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/"},{"name":"笔记","slug":"新知/笔记","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"2020","slug":"2020","permalink":"https://blog.amoswu.top/tags/2020/"},{"name":"Qt","slug":"Qt","permalink":"https://blog.amoswu.top/tags/Qt/"},{"name":"C++","slug":"C","permalink":"https://blog.amoswu.top/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.amoswu.top/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Qt C++ Windows10环境配置","slug":"Qt C++ Windows10环境配置","date":"2020-08-09T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"584e.html","link":"","permalink":"https://blog.amoswu.top/584e.html","excerpt":"","text":"笔者2020年开始，从事了C++开发的相关工作，目前国内主流的C++开发工具多建立在可视化框架Qt的基础上，这一篇我们就来讲一讲Windows10 系统下如何快速搭建Qt for C++环境。 1.简介1)C++简介C++是一种被广泛使用的计算机程序设计语言。它是一种通用程序设计语言，支持多重编程模式，例如过程化程序设计、数据抽象、面向对象程序设计、泛型程序设计和设计模式等。 2)Qt简介Qt是一个跨平台的C++应用程序开发框架。广泛用于开发GUI程序，这种情况下又被称为部件工具箱。也可用于开发非GUI程序，比如控制台工具和服务器。Qt被用于OPIE、Skype、VLC media player、Adobe Photoshop Elements、VirtualBox与Mathematica以及被Autodesk、欧洲空间局、梦工厂、Google、HP、KDE、卢卡斯影业、西门子公司、沃尔沃集团, 华特迪士尼动画制作公司、三星集团、飞利浦、Panasonic 所使用。 来自维基百科 ,IEEE Spectrum Programming Language 2020。 2. Qt下载目前Qt的同大多数框架一样，遵循两种版本推送方案，一种是稳定版，目前最新版本号为 5.15 ，另一种是预览版，目前最新版本号为 6.0 Snapshot。 Qt官网为 https://qt.io 。 Qt有多种下载方式，这里只贴出笔者使用的一种方式——清华大学开源软件镜像站 。此镜像站提供Linux、MacOS、Windows下的三种安装包，满足大多数开发者的开发环境。 3.安装在准备好安装包后，我们就要进入正题——安装Qt并配置环境了。 1)双击运行下载好的 qt-opensource-windows-x86-5.12.exe。 2)选择Next，进行下一步。 3)最新版会要求登录或注册一个Qt账户，这里的5.12.0版本支持跳过此步，最新版不支持，所以建议大家去注册一个。 4)继续点击下一步，再点击下一步，选择安装目录。 5)再次点击下一步，进行Qt creator 设置 选择显示的对应版本，我这里是Qt 5.12.0，勾选其中对应的Mingw，我这里的是Mingw 7.3.0 64bit。如果你还安装了Visual Studio开发环境，可以选择对应版本的MSVC。 6)再往后就是无脑下一步啦，知道看到下面这个界面，就说明安装和配置都完成啦~ 安装完成后，可以在开始菜单和桌面看到Qt Creator图标，双击打开就可以编写Qt C++代码咯~ :smile: 本期教程就到这里，下一期我们一起讲讲 Qt Creator 编辑器下的代码格式化~","categories":[{"name":"新知","slug":"新知","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/"},{"name":"笔记","slug":"新知/笔记","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"2020","slug":"2020","permalink":"https://blog.amoswu.top/tags/2020/"},{"name":"Qt","slug":"Qt","permalink":"https://blog.amoswu.top/tags/Qt/"},{"name":"C++","slug":"C","permalink":"https://blog.amoswu.top/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.amoswu.top/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"辉煌70载，与您同在","slug":"辉煌70载，与您同在","date":"2019-09-30T16:00:00.000Z","updated":"2026-01-30T07:08:16.000Z","comments":true,"path":"121.html","link":"","permalink":"https://blog.amoswu.top/121.html","excerpt":"","text":"爱祖国，首先要了解祖国；不了解，就说不上爱。 ——任继愈（前国家图书馆馆长） 70年，弹指一挥间。新中国在一代又一代的奋斗者接续奋斗下不断成长。我有幸成为奋斗者中的一员，在祖国母亲70华诞到来之际，我想借此文献上对祖国母亲的祝福！ 如同上面这句名言所说，爱祖国就应该先了解祖国。我搜集了新中国成立70周年以来的一些老照片，特意把它们制作成图片，与你一起共同回顾伟大祖国的成长历程。 网络上一直流行着一句话，“此生无悔入华夏，来生愿在种花家”。这也是新时代我们青年对伟大祖国表达的最深切的爱意。最近由陈凯歌等七位导演联合执导的电影《我和我的祖国》还没上映预售就突破了2亿元。“以小人物见证大时代，献礼新中国成立70周年”是这部影片的目标。电影上映前期，适逢电影主题曲《我和我的祖国》发行，还是那熟悉的旋律，还是那熟悉的歌词，不同的是歌曲背后的新故事。此歌曲的演唱者是华语乐坛著名的女歌手——王菲。王菲对歌曲的诠释也让这首经典旋律呈现出一种别样的自在、温暖、辽阔，营造出一种祥和的包容感。 歌曲25日在网易云音乐首发，短短五天的时间里，歌曲评论已超过8万条。我特意利用自己学到知识，抓取了这首歌9月25日-9月29日期间的3万多条热评数据，进行了整理分析，最终生成了如下的一张“词云热图”。 从图中热词的数目和字号大小，不难分辨，多数听过这首歌的网友都深深爱着祖国的这片热土，他们的声音也代表了今日中国14亿人民的心声。借此图，我也想深深的送上一句，“我的祖国，生日快乐！” 这盛世，如您所愿。我们生活的时代，是最好的时代，也是先烈们梦想中的时代。我相信，站在这通向伟大复兴的起点上，伟大祖国一定会越来越好！再一次，深深地祝福伟大祖国，繁荣富强！ 无论何时何地，我们都与祖国肩并肩。辉煌70载，与您同在！ 参考内容： [1] 微信公众号“拾遗” - 70张老照片告诉你，什么是新中国 [2] 百度百科 - 成渝铁路、武汉长江大桥等词条 [3] 百度百科 - 我和我的祖国（2019年陈凯歌等执导电影）词条 [4]网站 - 网易、阿里巴巴、腾讯等各大企业官网 [5]网易云音乐 - 《王菲-我和我的祖国》 部分图片来源于网络，侵权请联系删除","categories":[{"name":"特别博文","slug":"特别博文","permalink":"https://blog.amoswu.top/categories/%E7%89%B9%E5%88%AB%E5%8D%9A%E6%96%87/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"2019","slug":"2019","permalink":"https://blog.amoswu.top/tags/2019/"},{"name":"特别博文","slug":"特别博文","permalink":"https://blog.amoswu.top/tags/%E7%89%B9%E5%88%AB%E5%8D%9A%E6%96%87/"}]},{"title":"为什么“中台”这么火？","slug":"为什么“中台”这么火？","date":"2019-08-31T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"836c.html","link":"","permalink":"https://blog.amoswu.top/836c.html","excerpt":"","text":"00.引言从去年10月份以来，国内几大互联网公司相继进行了组织架构调整，这其中不乏有BAT（百度、阿里、腾讯）、海尔、滴滴、京东等公司，值得注意的是这一轮的组织架构调整各大公司都多出了一个名叫“中台”的架构。 在这样一个追求管理个性化的互联网时代，为什么国内各大互联网都要搭建一个或多个“中台”呢？说来原因有很多，我们不妨先从认识“中台”说起。 01.谁发明了“中台”？“中台”最早是由美军的作战体系演化而来的。美军在二战时期，以军来为单位作战；到了越南战争时期，以营为单位作战；再到中东战争的时候，则以7人或者11人的极小班排去作战，这是今天最灵活的军事组织，也是核心竞争力和打击能力最强的一个组织。而美军之所以能灵活作战，敢放这么小的团队到前方，是因为有非常强的导弹指挥系统，有非常强大的中台能力，能支持这样的小团队快速做判断，并且引领整个打击。 有着军事背景的“中台”又是怎样“跳槽”到互联网行业的呢？ 这就得说一说这家来自芬兰的游戏公司了，它的作品具有强大的生命力，它的全球累计用户规模已经超过10亿，它2015年时的估值就达到了52.5亿美元，它就是——Supercell。到目前为止，该公司已经开发和运营了包括《部落冲突》（Clash of Clans）、《海岛奇兵》（Clash Royale）在内的十余款超火爆游戏。这家公司的一年利润就有15亿美元，而这家公司的员工人数仅有不到200个人，公司里每一个开发游戏的小团队仅有6-7人。 读到这里，相信你已经猜到了。正是Supercell首先在互联网行业构建了“中台”。他们将游戏开发过程中公共和通用的游戏素材和算法整合起来，并积累了非常科学的研发工具和框架体系，构建了一个功能非常强大的中台。就这样，一套素材被用于多个项目的同时开发，“中台”架构就进入了人们的视野。 “中台”又是如何被引入到国内的呢？ 那就得从阿里巴巴说起了。2015年，阿里巴巴董事局主席、阿里创始人马云带领阿里一行高管前往Supercell公司进行了考察，考察过程中他们了解到在Supercell公司5-7人组成的独立开发团队被命名为“Cell”（细胞），这些Cell的协作得益于背后强大的中台的支撑。 回国后，阿里巴巴集团于2015年年底正式启动了“中台战略”，构建符合IT时代的更具创新性、灵活性的“大中台、小前台”组织机制和业务机制，即作为前台的一线业务会更敏捷、更快速适应瞬息万变的市场，而中台将集合整个集团的运营数据能力、产品技术能力，对各前台业务形成强力支撑。 从“中台”的诞生，到“跳槽”再到“移民”，中台的前世就我们已经了解清楚了。接下来我们一起来聊聊——什么是“中台”？ 02.什么是“中台”？迄今为止，“中台”（Middle Office）的定义有很多，我认为，下面两个定义是对“中台”的定义最佳的阐述。 定义1来自 ThoughtWorks 高级咨询师 王建 中台是真正为前台而生的平台（可以是技术平台，业务能力甚至是组织机构），它存在的唯一目的就是更好的服务前台规模化创新，进而更好的响应服务引领用户，使企业真正做到自身能力与用户需求的持续对接。 定义2来自得到 中台是一个能同时支撑多个业务，让业务之间的信息形成交互和增强的机制。 怎么？是不是有点抽象？让我来举几个例子帮助你理解一下什么是“中台”。 它可以是我们家用的“路由器”，我们在家要连接互联网，肯定离不开WiFi，而发射WiFi信号的路由器，在我们家庭上网的场景中充当的就是“中台”的角色。它即负责连接我们的联网设备，又负责与外网发生连接。 它也可以是维修工人的“工具箱”，在维修不同的机器时，都可以从工具箱中找出顺手的工具，从而避免“黑瞎子掰玉米”的现象。 它还可以是火遍全球的“老干妈”，吃面时加入它“调味”，烧菜时加入它“增香”，拌凉菜时加入它“提味”，这就是强大的“万能调料”。 说完中台的概念，我们还需要了解一下，当下互联网产业中，“中台”有哪些常见类型？ 在有些人眼里：中台就是技术平台，像微服务开发框架、Devops 平台、PaaS 平台，容器云之类的，人们都叫它“技术中台”。 在有些人眼里：中台就是微服务业务平台，像最常见的什么用户中心，订单中心，各种微服务集散地，人们都叫它“业务中台”。 在有些人眼里：中台应该是组织的事情，在释放潜能：平台型组织的进化路线图 (豆瓣) 中就提出了平台型组织和组织中台的概念，这类组织中台在企业中主要起到投资评估与投后管理的作用，类似于企业内部资源调度中心和内部创新孵化组织，人们叫它“组织中台”。 03.为什么选择“中台”？选择“中台”有很多原因，总结起来就是“实惠、精简、高效”。展开来说，“中台”具有以下优势： 服务重用：真正体现SOA理念的核心价值，松耦合的服务带来业务的复用； 服务进化：随着新业务的不断接入，共享服务也需从仅提供单薄业务功能，不断的自我进化成更健壮更强大的服务，不断适应各种业务线，真正成为企业宝贵的IT资产； 数据累积：各个业务的数据都沉淀在同一套中台服务，可以不断累积数据，最终发挥大数据威力； 快速响应：更快的通过共享服务的组合响应新业务； 降低成本：对于新业务，无需再投入新的重复的开发力量，减少人员成本； 效能提升：开发人员更专注某一领域，开发更快，更易维护。 众所周知，多数互联网企业的技术架构都是由“前台 + 后台”构成。而这种架构在大型项目以及多项目开发时存在很多问题，比如决策效率低下、“资源冗余、浪费频发”、“项目间与项目内协作能力较差”等等。这些问题在IT圈被多数从业者熟知的一个词就是“重造轮子”。 重造轮子，（英语：Reinventing the wheel）是重新创造一个已有的或是早已被优化过的基本方法，此用语常出现在软件开发或其他工程领域中。 搭建“中台”后，能有效解决上述问题，同时也完成了架构的“去中心化”，有效避免中心热点、雪崩等情况发生。而这其中“数据中台”的搭建，更加有益于大数据的发展，让数据高效、有序、合理地流通于各个业务之间，从而增强用户体验。 读到这里，你可能会不禁疑问，“中台”火归火，可是对于我自己这样一个个体来说又有什么意义呢？ 04.“中台”给我们的启示是什么？我个人非常认同“中台“提供给我们的不仅仅是企业的架构调整，而是一种”思维方式“。一种可以从具体的事务中抽离成普适的经验的方法论。 拿我个人来说，我之前在学生组织工作时，为了协调多部门搞好一个活动，常常会有活动总结会议。这种会议的目的在于，大家可以坐在一起，把各部门遇到的问题及解决方案，抽象成一条或多条适用于其他活动的经验，以便于推动组织更好地向前发展。学生组织主办的活动也好，公司部门也罢，都可以是Supercell中的一个Cell，学会这种思维，会让我们积累更多更有益于自身和组织发展的经验，形成增强回路，从而推动人生的“飞轮”不断向前！ 感谢你读到这里，祝你也能拥有“中台思维”！ 参考内容： [1] InfoQ - 白话中台战略（一）：中台是个什么鬼？ [2] 维基百科 - “重造轮子”的词条 [3] 钟华 - 《企业IT架构转型之道 阿里巴巴中台战略思想与架构实战》 [4] CSDN - 阿里中台(看图不说话) [5] 邵恒头条 - 2019.06.19 互联网公司为什么都在搭建“中台”？ [6] 架构师技术联盟 - 关于中台，你可能不知道的那些事！ [7] 维基百科 - “Supercell (游戏公司)”的词条 [8] Our story × Supercell - Supercell 官网 [9] 知乎 - 互联网公司中所谓中台是怎么定义的？ *部分图片源于网络","categories":[{"name":"新知","slug":"新知","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/"},{"name":"随笔","slug":"新知/随笔","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"随笔","slug":"随笔","permalink":"https://blog.amoswu.top/tags/%E9%9A%8F%E7%AC%94/"},{"name":"2019","slug":"2019","permalink":"https://blog.amoswu.top/tags/2019/"},{"name":"新知识","slug":"新知识","permalink":"https://blog.amoswu.top/tags/%E6%96%B0%E7%9F%A5%E8%AF%86/"}]},{"title":"什么是“沙盒创新”以及它背后的启示","slug":"什么是“沙盒创新”以及它背后的启示","date":"2019-08-02T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"80c1.html","link":"","permalink":"https://blog.amoswu.top/80c1.html","excerpt":"","text":"最近《邵恒头条》有一期栏目谈的是“以色列怎么做到‘沙盒创新’？”，收听过后，我大为触动。今天就和你聊一聊我从以色列”沙盒创新“背后得到的启示，以及我的一些思考。 一、什么是“沙盒创新”？首先来聊一聊什么是”沙盒创新“。如果你从未听说过这个词，单从字面意思上来理解，可以解释为”在某一不能动盒子内或者外进行的创新“。当然，如果你有计算机相关的知识，可能会知道”沙盒“是一个计算机术语，它是计算机安全领域的一种安全机制，它会为运行中的程序提供隔离环境。加上这一层，我们就可以给”沙盒创新“下一个准确的定义了。所谓的”沙盒创新“，就是盒子里装满了细沙，如果盒子不能动，产生的创新。换句话说，就是外部条件的限制，完全不能改变的情况下的创新。 我想，读到这里，你也一定会和我一样，产生了一个疑问——外部条件没法改变，从哪里还能产生创新呢？这个问题，同样也困扰了坐落于地中海东南岸及红海亚喀巴湾北岸的一个国家——以色列的人民。 二、以色列的“沙盒创新”一提到以色列，大多数人脑海中会浮现诸如“犹太人最多的国家”、“世界上人均年读书量最多的国家”、“发达国家”等等这样的标签。在开始介绍以色列的“沙盒创新”之前，请你和我一起先认识一下以色列这个国家。 以色列是一个位于西亚，坐落于地中海东南岸及红海亚喀巴湾北岸的主权国家。国土面积约为我国的0.2%**，人口总数约为900万（截止至2018年），人类发展指数0.903**，位列世界第22位（截止至2018年）。 人类发展指数（英语：Human Development Index，缩写为HDI），是联合国开发计划署从1990年开始发布用以衡量各国社会经济发展程度的标准，并依此将各国划分为：极高、高、中、低共四组。只有被列入第一组“极高”的国家才有可能成为已开发国家。指数值根据出生时的平均寿命、受教育年限（包括平均受教育年限和预期受教育年限）、人均国民总收入计算出，在世界范围内可作为各国之间的比较。分界标准：极高：0.800以上高：0.7990.700之间中：0.6990.550之间低：0.549以下 截止至2018年，中国大陆的人类发展指数为0.752，位列世界第86位。 —— 来自 维基百科“人类发展指数”和“人类发展指数列表”词条 以色列为代议民主制国家，采用议会制、比例代表制和普遍选举制。总理为政府首脑，议会为立法机关。以色列为一发达国家，经济合作与发展组织成员国，2018年其名义国内生产总值排名世界第34。该国具有较高水平的劳动力，为全球教育程度最高的国家之一，其公民拥有高等教育学历的比例亦为世界最高之一。其生活水平为中东最高和亚洲第四高，其人口预期寿命亦居世界前列。 读完上面的介绍，是不是刷新了你对以色列这个国家的认识呢？ 下面我们回到正题，聊一聊以色列的“沙盒创新”。在这个国土面积小的可怜的弹丸之地，有4000多家科技创业公司用他们的方式改变着我们每一个人的生活。是的，是改变我们每一个人的生活。 读到这里你可能不信，让我来给你举上几个例子。我们日常生活中的很多发明都源自于以色列，比如 我们目前离不开的U盘，就是以色列人Amir Ban, Dov Moran 和 Oron Ogdan发明的，他们都来自以色列M-Systems公司； 还有今天中国大多数人都在用的即时通讯工具QQ，它脱胎于ICQ，ICQ是1996年由以色列Mirabillis公司发明的； 还有我们经常吃的圣女果，这种可爱的小西红柿的野生品种来自南美，目前人工种植的有三个品种，其中最主要的特别甜美的品种Tomaccio是在以色列希伯来大学教授Prof. Nahum Keidar 和 Prof. Chaim Rabinovitch领导下花了十二年时间杂交培育出来的。 这些都是以色列发明创新的“冰山一角”，读到这里，相信你已经消除了“以色列是一个改变我们每一个人生活的国家”的疑问了吧。 这些发明和创新都离不开一个共同的密码，创新还有共同点？是的，这个密码究竟是什么呢？ 第一，有限制才有创新； 第二，创新有模式可循。 这听起来是不是有一点反常识？我们经常会听到这样的抱怨，条件不允许、人才储备不够，我们不能创新，也就是限制太多，将创新扼杀在了摇篮里。但以色列SIT全球创新公司副总裁泰马尔·车路奇却说，“限制才能成为激发创新的动力”。正是种种的“限制”，逼着以色列人必须创新，因为“不创新就会死”。 今天被普及到全世界的滴灌技术，就是很好的例子。之所以会发明滴灌技术，就是因为以色列太缺水了，必须要让每一滴水都发挥出最大的作用。所以以色列人在灌溉设备上，用足了高科技，比如智能监控、防堵塞的药剂、充气系统、回收循环系统等等。他们生生把水的利用率，从传统的15%提升到了95%以上。 靠着滴灌技术，以色列不仅实现了农产品自给自足，还能出口欧洲国家。而且，滴灌技术还被推广到了全世界。所以你看，正是以色列的水资源限制，激发了农业技术的创新。 让人感到更反常识的是第二点，“创新有模式可循”，即以色列人认为创新是可以复制的。这听上去太不可思议了，我们平时所说的灵感啊、创新啊，都是灵光乍现才有的，怎么一下子就变得可能有现成的模式，而且还能复制了呢？ 要解答这个问题，我们首先要明确我们所说的创新到底是什么，以色列人的定义是”新的、有价值的、可行的“这三个要素同时满足才构成创新。 紧接着你要思考，如果要实现这样的创新，我们需要打破什么？这也很明确，就是打破思维定势。 以色列人把思维定势梳理成三种最常见的类型，从小学就开始训练学生如何打破思维定势： 第一种是功能型的思维定势，就是习惯性把事物锁定为某种传统功能，比如墨镜，只有遮阳功能。但在未来，它也可能变成一个可穿戴的微型显示器。 第二种是结构型思维定势，也就是你认为，一个事物的结构就应该是你看到的那个样子。比如，最早的冰箱因为没有电，所以总是把大冰块置于顶部进行自上而下的冷气循环，这就导致最早的那些电冰箱的设计也总是冷冻室放在上面，冷藏室放在下面。但其实，我们显然用冷藏的功能更频繁，为了便利，应该放在上面嘛。 第三种是关系型思维定势，就是认为两个事物之间的关系是固定的。比如说，孩子看电视，你觉得影响学习，就不让他看。你认为，电视和学习之间，是势不两立的关系。但其实，你可以和孩子约定，每看一小时电视，就得读一小时书。这样，看电视和学习就变成了互相促进的关系。 打破这样的思维定势，又要靠什么？泰马尔说，SIT就是一套帮我们打破思维定势的创新方法论。SIT是Systematic Inventive Thinking的缩写，意思是系统创新思维。 这套方法论讲究的是不做加法、不从外部要资源，也就是说，不去试图改变盒子本身。但是，你要从“盒子里面”的系统着手，聚焦于这个系统当中到底有哪些已有的资源，是否可以充分开掘其新的价值。这就是一种不抱怨、不抗拒的沙盒创新。 SIT创新思维，总共包括五种核心工具。不过，我认为这里面最实用、最容易操作的工具，是减法工具。我来给你介绍一下。 简单来说，减法工具指的是，在一个系统里，减去最重要的部件，反而却发掘其他辅助部件的潜能。 举个简单的例子来说，洗衣液。洗衣液的功能，当然是把衣服洗干净，所以对洗衣液来说最核心的部件，就是去污成分了。那么，如果你把这部分拿走呢？不能去污，其实还有香气呀。所以，一个不能去污的洗衣液，可以当作衣服的清新剂。 这就很有用啊，因为现代人换衣服很频繁，每天穿一套不一样的，非常普遍。穿一次就洗吧，洗衣液的去污成分对衣服耗损很大。不洗吧，穿着又别扭。清新剂恰恰解决了这个问题。这个想法，以色列SIT公司在1996年就提出来了。四年之后，宝洁公司推出了一款叫Febreze的清新剂，创造了清洁市场的新品类。 这种减法工具就是以色列的系统创新思维的核心方法，是不是读完让人耳目一新呢？ 三、我的几点思考在真正了解了什么是“沙盒创新”之后，我产生了几点思考，下面和你一起聊一聊。 1.减少抱怨，多多行动。做事和创新在以色列人的角度，都是有规律可循的。找到这个规律的前提是“减少抱怨，多多行动”。正如我们在本文刚开始讨论的那样，以色列被我们熟识多发生在每年的“世界读书日”，这一天，多数商家和媒体都会宣传读书的重要性，这其中就必须要提到世界上最勤奋的以色列人的人均年读书本数。当代书画家范增曾经说过，“苍天没有给我什么独得之厚，我的每一步前进，都付出了通宵达旦的艰苦劳动和霜晨雨夜的冥思苦想”。所以，行动起来吧，中彩票的第一步是买一张彩票，对吗？ 2.学会做减法，轻装上阵。生活在种系统复合环境下的我们，无论是事业、家庭还是个人，都在各自不同的系统中运行着。要想充分发掘这个系统的潜能唯有做好减法，轻装上阵，才会又不一样的风景呈现在我们面前。 3.考虑事情多从整体出发，会有意想不到的收获。考虑事情多从整体出发，会有意想不到的收获。换一种方式讲，就是要有大局观。这好比这几个月以来，被美国举国家之力制裁的华为一样，要不是创始人任正非的远见与大局观，中国怕是又要出现一个“中兴”。整体性看待事物的重要性就不言而喻了。 4.要不断打破思维定势，变得更加理性。这一点思考也是我最近在学习得到课程《蔡钰·批判性思维15讲》时得到的一个共通的思考，正如课程中所说“你的知识面越广，你的思维局限和漏洞越少，你的思考就越自由”。而拥有多大的思考自由度，取决于你是否有更少地思维定势，或者说是否有批判性思维。所以，勇敢迈出那一步吧，打破那蛋壳一样的思维定势，看见不一样的世界。 以上，就是我对“什么是’沙盒创新‘以及它带给我的思考”的全部内容，感谢你读到这里，祝你也能做一个不断创新的人。 参考内容： [1] 邵恒头条 - 2018.8.1 以色列怎么做到“沙盒创新”？ [2] 百度百科 - “沙盒”的定义 [3] 维基百科 - “人类发展指数”、“人类发展指数列表”词条 [4] 十个影响我们日常生活的以色列发明 - 张平特拉维夫的新浪博客 [5] 得到课程《蔡钰·批判性思维15讲》","categories":[{"name":"新知","slug":"新知","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/"},{"name":"笔记","slug":"新知/笔记","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"随笔","slug":"随笔","permalink":"https://blog.amoswu.top/tags/%E9%9A%8F%E7%AC%94/"},{"name":"2019","slug":"2019","permalink":"https://blog.amoswu.top/tags/2019/"},{"name":"新知识","slug":"新知识","permalink":"https://blog.amoswu.top/tags/%E6%96%B0%E7%9F%A5%E8%AF%86/"}]},{"title":"什么是“认知折叠”？","slug":"什么是“认知折叠”","date":"2019-07-02T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"3b91.html","link":"","permalink":"https://blog.amoswu.top/3b91.html","excerpt":"","text":"最近在得到大学2019夏季班开学典礼演讲和在得到APP收听《罗辑思维》第762期时，学到了一个新的知识——认知折叠。 下面音频与原文一同分享。 音频在这儿(●—●) 策划人：李仲轲 和你一起终身学习，这里是罗辑思维。 昨天，我们在上海举行了得到大学2019夏季班的开学典礼。我是最后一个发言的，在发言里面，我跟大家讲了一个“认知折叠”的新概念。 这是什么意思呢？这是衡量人类文明进步的一种重要尺度。 过去，我们说文明进步，主要是用数量来衡量的：财富越来越多、效率越来越高、能量调动的量级越来越大等等，都是数量概念。仅仅如此吗？不，除了数量之外，还有一个“认知折叠”的维度。 我们来看一个例子：午餐肉。我们很多人喜欢吃午餐肉，尤其是涮火锅的时候。午餐肉谁发明的呢？二战之前的美国人。 有一个说法，说让美军赢得第二次世界大战的，除了武器装备将军士兵之外，就是这样不起眼的东西，午餐肉。 给你看几个数字，二战中，美国军人靠着午餐肉，一天能够摄入至少4300卡路里的热量。美国的对手德国军队呢？平均一人一天是3000卡路里的热量。日本人更惨，每天只有2000卡的摄入量，还不到美国的一半。 你可能对数字还没什么概念。举个例子。我，罗胖，不用干体力活。按照世界卫生组织的标准，每天需要2300卡。你就明白了，二战时候的日军在战场上拼死拼活，每天的卡路里摄入量居然比不上我。吃不饱饭，打仗这不肯定要输么？ 你可能会说，这不奇怪啊。日本穷，美国富。美国那么广大的国土，粮油肉蛋奶出产丰富，士兵吃得好，这不是应该的吗？没那么简单。战场，不是市场。你国力强、有充足的供应就可以了。战场的情况瞬息万变，极其复杂。 你就想，美国在二战期间，总兵力有上千万人，而且分布到欧洲战场和太平洋战场。细分到每个兵种，每个部队，战场不一样，执行的任务不一样，很多还都在运动中。如果你是管美军后勤的官员，就算你手头有无穷无尽的资源，仅仅面对这个巨大的复杂性，你是不是要疯？我就看到过一个材料，说第一次世界大战的时候，美国的统帅潘兴将军在欧洲打仗，还要通知国内后勤部门，说你们别往欧洲运什么浴缸、书橱、割草机和痰盂了。你看，这么大规模的物质投送，不是你能不能在数量上能保证供给的问题。是细部的复杂性难题，解决不了。稍一出错就要惹大麻烦。 别的不说了，仅仅在战场上让队伍吃饱饭这件事，请问你后勤部门怎么做？难道每个小分队都配一个炊事班？ 那这个炊事班，要不要带食材？要不要带锅具餐具？要不要带燃料？各自都带多少？带少了不够吃，带多了，不是资源不够的问题，是影响军事任务的执行。你怎么保证把合适数量，合适结构的食物和物资，投放给合适的部队呢？这是个大难题吧？ 刚才我们说，日本军队一天一人只能有2000卡路里的热量，其实不完全是因为国家穷，粮食资源不够。还因为他们吃的主要是米饭做的饭团。就算没有肉类和蔬菜，仅仅保证给士兵吃饭团，复杂度都高得吓人。你得带米吧？得有柴有锅有水才能煮饭吧？仅仅这些条件，在战场上满足起来就很不容易。而且米饭，做熟了很快就会馊，所以也不能一次做成长期储存。而且炊事班在战场上是不能随便生火的，炊烟一飘出去，被敌人侦察到了，接下来可不就被一锅端了么？你看，在很多情况下，就算部队有米有柴，配送不上去，或者不方便做，士兵在战场上也得饿肚子。 明白了这一点，你再回头来看午餐肉，就知道它的好处了。 午餐肉是罐头装的熟食，不需要额外加工，想吃热的，用开水烫一下就可以。吃起来也很方便，开罐即食，用勺子舀着就行。要分给别人也很容易，把肉拿出来，用刺刀切成小块就可以了。什么炊事班，什么柴米油盐，什么餐具灶具，什么做饭时机，一概不用。 不仅是热量的总量问题，还有营养搭配问题呢？干过体力活的人都知道，消耗了大量体力之后，光是吃干粮、补充碳水化合物是远远不够的，人必须得吃蛋白质、吃油脂。这对午餐肉来说，不是问题，只需要在后方的工厂里面改变一下配方就行了。一盒午餐肉里面不仅有肉，还有淀粉，还可以加入你想加入的任何其他营养物质。 还有一点，你想过没有？毕竟那是战争时期，即使像美国那么富有的国家，资源也是紧缺的。实际上二战的时候，美国也实施过粮食配给。那怎么才能保证战场上的士兵都能吃到肉呢？秘密也在午餐肉的罐头盒子里。 我们都知道，美国人是不怎么吃碎肉，他们要吃整肉，更是不吃动物内脏下水的。但是做成午餐肉，你还分得清什么是碎肉，什么是内脏下水吗？据说当年生产午餐肉的荷美尔公司，可以做到猪从工厂的一头进去，白骨另一头出来，一点都不浪费。如果是直接供应整块的肉，那肉的质量稍有变化，哪怕肉稍微碎了一点，士兵都看得出来，这影响士气。但是午餐肉是把肉、淀粉、盐、食品添加剂搅在一起的，成分变化没那么明显。实际上，到了二战后期，美国的食品供应也紧张，午餐肉里的淀粉比例也在不断上升，到了后来，甚至肉的成分都变了，从肥瘦混合的猪肉、变成纯肥肉、最后甚至会添加猪内脏或者其它肉。 不仅如此，还有运输上的优势。午餐肉压缩在罐头里面，运输起来非常方便，无论是轮船火车运，还是飞机空投都可以。还不怕变质，在没有冰箱的情况下能放3年。还有一点，运输的复杂性也大大降低，不会出现给一个部队运去200斤蔬菜，但是没有肉蛋奶的情况。这种错误不会发生。就那么一盒盒的，数数儿就可以了。在整个二战中，至少有7000万公斤，差不多是1.4亿罐的午餐肉被运往了前线，让美国大兵敞开了吃。美国人就是这么打赢二战。 说了这么多，我们再来看午餐肉的本质到底是什么？它不止是一块装在罐头里的肉，他本质上是把畜牧业、食品加工业、食品化学、交通运输业等多个领域，解决各种问题的方法，一个庞大的认知体系，全部封装进了一个罐头里，大大降低了问题的复杂性。这是什么，这就是我们今天要讲的那个主题：认知折叠。 你看是不是？除了数量之外，这是衡量人类文明进步的一个重要尺度。 过去有一期罗辑思维节目，我们曾经讲过集装箱的故事。就那么一个方方正正的大铁箱子，也没有多少技术含量，但是它就是能把国际海运的成本降下来90%以上，彻底改变了20世纪全球供应链的样子。把巨大的复杂性折叠成简单的工具，这也是认知折叠。 还有，得到App里面的《薄世宁·医学通识50讲》里面讲到药，他给药下的定义是，药是医学解决方案的物质载体。每一颗药，也是把现代医学对这个病的所有知识，那是个多么复杂的体系，折叠进了一颗小小的药丸，这也是认知折叠。 你看，文明的进步，不仅取决于拥有多少资源、能量和信息，更取决于能把这些资源、能量和信息折叠成多么普通的样子。 昨天是得到大学2019夏季班的开学典礼。最后说几句得到大学。 我们创办的得到大学，不是商学院，也不止针对成功人士，它服务于所有正处在事业上升期的对自己有期待的人。我们挑选那么多各行各业的精英，做你的同学，花那么多精力大家打磨知识产品，目的是啥？其实也是希望，能在这三个月的学习期间，为你做一次奇妙的“认知折叠”。把那么多复杂的知识，各行各业的经验，为你折叠成普通的样子，让你打包带走。 现在，得到大学2019秋季班已经开始招生。我把报名链接放在这个音频附属的文稿里面。如果你报名得到大学，如果你被成功录取，我知道，因为你有“认知折叠”，所以你会不虚此行。 好，罗辑思维，明天见。","categories":[{"name":"新知","slug":"新知","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/"},{"name":"随笔","slug":"新知/随笔","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://blog.amoswu.top/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"2019","slug":"2019","permalink":"https://blog.amoswu.top/tags/2019/"},{"name":"新知识","slug":"新知识","permalink":"https://blog.amoswu.top/tags/%E6%96%B0%E7%9F%A5%E8%AF%86/"}]},{"title":"汇编与接口知识梳理","slug":"汇编与接口知识梳理","date":"2019-06-18T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"4b6c.html","link":"","permalink":"https://blog.amoswu.top/4b6c.html","excerpt":"","text":"马上就迎来大学生涯中最后一次期末考试了，在这里我把《微机原理与接口》课程的知识按照张春芳老师给的提纲进行了梳理。下面正文是文字的形式，文末还有思维导图的形式一并共享给大家，期待和大家一起考出好成绩。 说明按照老师给的提纲顺序，我对每一个点进行了梳理，覆盖率98%，并在每一个点后面附上了课本出处页码，以方便查阅课本原文。有的点没有达到100%覆盖，是我复习过程中遇到的问题，我会在向老师求教后及时更新。 这一份知识梳理是我在刚刚过去的2天里，利用了20多个小时的时间，翻阅课本，查阅PPT后逐字手敲的结果，可能其中会有疏漏，还请见谅！ Chapter 1-31.二进制数据类型、表示、范围及其转换 P11-13 定点整数 无符号整数：只表达0和正整数 8位范围：0-255 N位范围：0~2^N-1 有符号数：占用机器数的最高位当符号位，0表示正，1表示负 原码和反码 补码 原反补码的转换 正数的原码、反码和补码都相同。 负数原码和反码的相互转换：符号位不变，数值位按位取反。 负数原码和补码的相互转换：符号位不变，数值位按位取反,末位再加1。2.物理地址、逻辑地址的概念及转换计算 P23 逻辑地址：“段地址：偏移地址”的形式表示的地址 物理地址：将逻辑地址中的段地址左移二进制4位，加上偏移地址20位所组成的地址 转换：段地址×16+偏移地址=物理地址（可以理解为段地址末尾补一个零）3.段地址、偏移地址的寄存器表示及计算 P23-24 代码段 - CS：IP 堆栈段 - SS：SP 数据段 - 存放当前运行程序所用的数据。DS存放数据段的段地址，存储器中的操作数的偏移地址则由各种主存寻址方式得到，称之为有效地址EA 附加段 - 是附加的数据段，也用于数据的保存。 使用BP基址指针寄存器访问主存，则默认是SS段，同时也允许段超越。4.汇编语言语句的格式 P25 P54-56 执行性语句 格式 - 标号: 处理器指令助记符 操作数, 操作数 ;注释 说明性语句 格式 - 名字 伪指令助记符 参数,参数,······ ；注释 标号与名字：是用户自定义的符合汇编程序语法的标识符 标识符 最多由31个字母、数字及规定的特殊符号（_、$、?、@）组成 不能以字母开头 不能是汇编程序采用的保留字 助记符：是帮助记忆的符号，反映指令的功能 操作数和参数 处理器指令的操作数可以是一个具体的常量，也可以是保存在寄存器中的数据，还可以是一个保存在存储器中的变量。 伪指令的参数可以是常量、变量名、表达式等，可以有多个，参数之间用逗号隔开。5.指令的寻址方式的类型及特点 P24-29 立即数寻址：用常量表达具体的数值 寄存器寻址：用寄存器名表示其中的内容 操作数可放在：AH/AL/BH/BL/CH/CL/DH/DL/AX/BX/CX/DX/SI/DI/BP/SP 还可以放在段寄存器中：CS/DS/SS/ES 存储器寻址：用存储器地址代表保存的数据 直接寻址 其默认段地址在DS段存储器中，可以使用段超越前缀来改变例：MOV AX，[2000H] 寄存器间接寻址 在8088/8086中寄存器可以是BX/BP/SI/DI例：MOV AX，BX 寄存器相对寻址 寄存器可以是BX/SI/DI，默认是数据段DS 也可以是BP，默认是堆栈段SS 都可用段超越前缀改变 例：MOV AX，[SI + 06H] 基址变址寻址 BX或BP + SI或DI = EA（有效地址） 例：MOV AX，[BX + SI] 或 MOV AX，[BX] [SI] 都可用段超越前缀改变 相对基址变址寻址 BX或BP + SI或DI + 位移量 = EA（有效地址） 例：MOV AX，[BX + DI - 06H] 都可用段超越前缀改变6.汇编指令的功能、格式及医用，包括对标志位的影响情况 P29-45 P47 数据传送类指令 通用数据传送指令 - 传送指令MOV 功能：把一个字节或字的操作数从源地址传送至目的地址 格式：见P29 不影响任何标志位 目的操作数和源操作数必须类型一致，否则为非法指令 堆栈操作指令 - PUSH、POP 功能：堆栈是一个“先进后出”的主存区域，使用SS段寄存器记录段地址；堆栈只有一个出口，即当前栈顶，用堆栈指针寄存器SP指定栈顶的偏移地址。 入栈指令PUSH会使堆栈指针SP减2，出站指令POP会使堆栈指针SP加2。 格式：见P31 不影响任何标志位 标志操作指令 可以直接读写标志寄存器的内容以及可以直接改变CF、DF、IF标志的状态的指令 地址传送指令 - LEA 功能：将存储器操作数的有效地址（段内偏移地址）传送至16位通用寄存器中 格式：见P33 不影响任何标志位 算术运算类指令 加法和减法指令 - 加法指令ADD、ADC、INC，减法指令SUB、SBB、DEC、NEG和CMP 功能：它们分别执行字或字节的加法和减法运算 格式：见P33 除INC和DEC不影响CF标志外，其他按定义影响全部状态标志位 符号扩展指令 CBW ;字节转换为字：AL符号扩展成AX CWD ;字转换为双字：AX符号扩展成DX 乘法和除法指令 乘法指令 MUL ;无符号数 IMUL ;有符号数 除法指令 DIV ;无符号数 IDIV ;有符号数 位操作类指令 逻辑运算指令 - AND、OR、XOR、TEST、NOT 功能、格式：见P37 AND(与)/OR(或)/XOR(异或)/TEST(测试)会使CF、OF都清零，其他标志位按定义影响。NOT(非)不影响任何标志位。 串操作类指令 控制转移类指令 条件转移指令 JZ/JNZ：利用零标志ZF，分别判断结果是0（相等）还是非0（不等） JS/JNS：利用符号标志SF，分别判断结果是负还是正 JO/JNO：利用溢出标志OF，分别判断结果是溢出还是没有溢出 JC/JNC：利用进位标志CF，判断结果是有进位（1）还是无进位（0） 循环指令 LOOP ;CX←CX-1 ;若CX≠0，转移 循环次数必须放在CX中 JNZ ;不为0转移 JCXZ ;为0循环：CX=0，转移 中断指令 21号中断 INT 21H ;屏幕显示 处理器控制类指令7.汇编伪指令的类型、格式及应用 P61 DB：字节（Byte）类型，分配一个或多个字节单元 DW：字（Word）类型，分配一个或多个字单元，每个数据是字量、16位数据 DD：双字（Dword）类型，分配一个或多个双字单元，每个数据是双字量、32位数据8.汇编语言编程的上机过程 用编辑器编辑代码后保存为汇编源文件（.asm）→经过编译得到目标文件（.obj）→经过连接生成可执行文件（.exe）9.汇编语言程序段的阅读、源程序的编写 P61-74CHAPTER 4-51.总线类型及特点 P94-95 特点：总线是功能部件之间实现互连的一组公共信号线，用作相互间信息交换的公共通道。 总线类型 按信息传递方向分 单向总线 输入总线或输出总线 双向总线 按数据传输方式分 并行总线 串行总线 按传输的信息种类 数据总线 地址总线 控制总线 扩展总线 局部总线2.8086/8088引脚功能和类型 P98-108 AD7AD0、A15A8、A19/S6~A16/S3 地址/数据总线：传输地址信号，一般数据都是双向传输，在主从模块间传送、交换数据信息。 读写控制：控制存储器或I/O端口进行数据传输 ALE - 高电平有效 IO/-M - 高低均有效，高电平表示CPU访问I/O接口，低电平表示CPU访问存储器 -WR - 低电平有效，写控制 -RD - 低电平有效，读控制 HOLD/HLDA 总线请求/响应：均为高电平有效 RESET 复位：高电平有效，8088复位后，CS = FFFFH，IP = 0000H，复位后第一条执行的指令物理地址从FFFF0H处开始。3.8086/8088功能结构和存储器结构 P136-137 偶存储体：对应所有偶地址单元，接微处理器的低8位D7~D0 奇存储体：对应所有奇地址单元，接微处理器的高8位D15~D84.8086/8088工作模式的配置结构：3：8地址译码器、地址锁存器类型和应用 P99-107 8086/8088可以在两种工作模式下工作，即最小模式和最大模式 最小模式－－即系统中只有8086（或8088）一个微处理器。最小模式是单处理器系统。系统中所需要的控制信号全部由8086（或8088）CPU本身直接提供 最大模式－－系统中有两个或两个以上的微处理器，即除了主处理器8086（或8088）以外，还有协处理器（8087算术协处理器或8089 输入/输出协处理器）。最大模式可构成多处理器系统，系统中所需要的控制信号由总线控制器8288提供 可根据图计算3:8译码器地址范围5.8086/8088系统总线的类型 P107-1116.存储器的类型、特点及典型芯片 P113-129 随机存储器（RAM） 静态RAM（SRAM） 6116 动态RAM（DRAM） 4164 只读存储器（ROM） 可擦除可编程ROM（EPROM） 2716/2732/2764 2K8/4K8/8K*8 电擦除可编程ROM（EEPROM） 2816 闪速存储器 29C5127.8086存储器的分体结构、与CPU的连接方式 P131-1388.存储器的组织：芯片地址线、数据线和片数、组数计算 P131-135 要求在给出容量的情况下，可求出存储芯片的地址线、数据线；并可计算已知总容量和单片容量的情况下的片数9.中断类型及特点 P159-160 内部中断 除法错中断 指令中断 单步中断 外部中断 非屏蔽中断 屏蔽中断10.中断相关概念及计算 P161-165 中断向量：是指早期的微机系统中将由硬件产生的中断标识码（中断源的识别标志，可用来形成相应的中断服务程序的入口地址或存放中断服务程序的首地址） 中断向量表：是一种表数据结构，是中断向量号与其对应的中断服务程序入口之间的链接表。 中断向量号（中断类型）：指当出现需要时，CPU暂时停止当前程序的执行转而执行处理新情况的程序和执行过程。 以上三者关系:中断向量=[中断号 * 4], 其中方括号的含义是内存单元的内容.(即中断向量表刚好存放在内存绝对地址0开始的位置)11.中断过程 P152-154 中断请求 中断判优 中断响应 中断处理 中断返回Chapter 6-121.I/O接口、端口的概念、编址方法 P140-143 I/O接口：是主机与被控对象进行信息交换的纽带，一个接口芯片会有一个或多个端口 I/O端口：简单理解为输入输出端口（IN、OUT） 编址方法 I/O端口与存储器地址独立编址 I/O端口与存储器地址统一编址 I/O地址译码2.4种数据传送方式的类型、特点及比较 P146 见附表1 3.无条件传送、查询传送的原理、结构和程序段 P146-152 见附表2-1、2-2、2-3 4.8259功能、结构、引脚 P164-166 功能：管理Intel 8080/8085和Intel 8086/8088微处理器的可屏蔽中断 一片8259A可以管理8级中断，可扩展至64级 每一级中断都可单独被屏蔽或允许 在中断响应周期，可提供相应的中断向量信号 有多种工作方式，可以通过编程来选择 结构及引脚 中断控制 - 3个8位可读写寄存器 IRR（中断请求寄存器）：1表示有中断请求，0表示无请求 ISR（中断服务寄存器）：1表示正在服务，0表示没有被服务 IMR（中断屏蔽寄存器）：1表示被屏蔽，0表示允许该中断 与处理器接口 中断级联5.8253功能、结构、引脚、工作方式、初值计算、控制字、初始化编程 P182-190 功能 具有三个独立的16位减法计数器 每个计数器可按二进制或十进制计数 每个计数器的计数速率可达2MHZ 每个计数器有六种工作方式 全部输入输出都与TTL电平兼容 结构与引脚 数据总线缓冲器 8位双向3态缓冲器，CPU与8253数据联络通道 读写控制电路 CS—片选信号RD—读8253 WR—写入8253 A0、A1—计数通道地址选择 控制字寄存器 8位寄存器，在8253初始化时，由CPU写入控制字，以决定计数通道的工作方式 计数器通道 计数器0、计数器1、计数器2独立16位减法计数器，计数值可写入或读出 引线 CLK—时钟脉冲输入线 GATE—门控信号输入，为低时禁止计数器计数 OUT—计数/定时输出，当计数到0时输出信号 A0、A1—通道地址选择00—计数器0；01—计数器1；10—计数器2；11—控制字寄存器 工作方式 方式0：计数结束中断 方式1：可编程单稳脉冲 方式2：频率发生器（分频器） 方式3：方波发生器 方式4：软件触发选通信号 方式5：硬件触发选通信号 初值计算 见课本P187 控制字 控制字的作用是决定8253各计数器工作方式；控制字寄存器实际上是3个，分别控制三个计数器，但它们的端口地址相同。 D7、D6：计数器选择 00 - 计数器0 01 - 计数器1 10 - 计数器2 11 - 非法 D5、D4：读写格式 00 - 计数器锁存 01 - 只读写计数器的低8位，高8位自动为0 10 - 只读写计数器高8位，低8位自动为0 11 - 先读写计数器低8位，再读写高8位 D3D2D1：计数器工作方式 000 - 方式0 001 - 方式1 ×10 - 方式2 ×11 - 方式3 100 - 方式4 101 - 方式5 D0：计数数制，决定计数器按二进制计数或BCD码（十进制）计数。 0 - 二进制 1 - BCD码（十进制） 初始化编程 见课本P188-1906.8237功能 有4个独立DMA通道，每个通道均可独立传送数据 每个通道DMA请求都可分别允许和禁止 每个通道均有64KB寻址和计数能力（16位地址寻址能力） 有4种DMA传送方式，分别为单字节传送、数据块传送、请求传送和级联传送方式 需要更多数据传送通道可把8237A级联 7.8255功能、结构、引脚、工作方式、控制字及连接打印机的应用 P210-221 功能 一个并行输入、输出的LSI芯片，多功能的I/O器件，可作为CPU总线与外围的接口 具有24个可编程设置的I/O口，即3组8位的I/O口为PA口，PB口和PC口 结构与引脚 RESET：复位输入线，当该输入端处于高电平时，所有内部寄存器（包括控制寄存器）均被清除，所有I/O口均被置成输入方式 CS：芯片选择信号线，当这个输入引脚为低电平时，即/CS=0时，表示芯片被选中，允许8255与CPU进行通讯;/CS=1时，8255无法与CPU做数据传输 RD：读信号线，当这个输入引脚为低跳变沿时，即/RD产生一个低脉冲且/CS=0时，允许8255通过数据总线向CPU发送数据或状态信息，即CPU从8255读取信息或数据 WR：写入信号，当这个输入引脚为低跳变沿时，即/WR产生一个低脉冲且/CS=0时，允许CPU将数据或控制字写入8255 D0～D7：三态双向数据总线，8255与CPU数据传送的通道，当CPU 执行输入输出指令时，通过它实现8位数据的读/写操作，控制字和状态信息也通过数据总线传送 工作方式 方式0：基本输入输出方式 方式1：选通输入输出方式 方式2：双向选通输入输出方式 控制字 方式控制字，详见附表3-1 端口C置位/复位控制字，详见附表3-2 连接打印机应用 见附表3-301、3-302、3-401、3-402 8.8251/8250功能、串行通信的波特率及波特因子 P241-256 功能 实现了起止式串行异步通信协议，支持全双工通信 通信字符可选字数据位为5~8位，停止位1、1.5或2位 可进行奇偶校验，具有奇偶、帧、溢出错误的检测电路 波特率 在串行通信中，用 “ 波特率” 来描述数据的传输速率。所谓波特率，即每秒钟传送的二进制位数，其单位为 bps ( bits per second )。它是衡量串行数据速度快慢的重要指标 波特因子 波特因子就是发送／接收 1 个数据( 1 个数据位)所需要的时钟脉冲个数，其单位是个／位 例:波特率 =9600bps ，波特率因子 =32 ，则 接收时钟和发送时钟频率 =9600 × 32=297200Hz 9.模拟接口的DAC/ADC芯片 P258-271 其他整理芯片名称与型号整理见附表4 相关下载思维导图下载http://t.cn/AiN1H6TF 附表图片下载http://t.cn/AiN1HPGk 最后，深深地感谢这一年为我们专业课辛勤付出的张春芳老师！ Mind Mapping by XMind: ZEN Pictures Designed by PowerPoint 2019 2019/06/19 21:59 最近一次更新： 2019/06/24 10:34","categories":[{"name":"知识整理","slug":"知识整理","permalink":"https://blog.amoswu.top/categories/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"2019","slug":"2019","permalink":"https://blog.amoswu.top/tags/2019/"},{"name":"汇编","slug":"汇编","permalink":"https://blog.amoswu.top/tags/%E6%B1%87%E7%BC%96/"},{"name":"微机原理","slug":"微机原理","permalink":"https://blog.amoswu.top/tags/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"},{"name":"Study","slug":"Study","permalink":"https://blog.amoswu.top/tags/Study/"},{"name":"HBTU","slug":"HBTU","permalink":"https://blog.amoswu.top/tags/HBTU/"}]},{"title":"汇编上机代码整理","slug":"汇编上机代码整理","date":"2019-06-04T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"8f39.html","link":"","permalink":"https://blog.amoswu.top/8f39.html","excerpt":"","text":"教材版本说明 Textbook version Title： 16/32位微机原理、汇编语言及接口技术教程 修订版 Author： 钱晓捷 Instructor： 张春芳 河北师范大学 代码部分01.屏幕打印‘Hello，how are you’123456789101112131415161718; hello，how are youDATA SEGMENT STRING DB &#x27;hello.how are you!&#x27;,&#x27;$&#x27; ORG 100HDATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATABEGIN: MOV AX,DATA MOV DS,AX LEA DX,STRING MOV AH,09H INT 21H MOV AH,4CH INT 21HCODE ENDS END BEGIN 02.屏幕打印 1+2+3 的结果123456789101112131415161718; 1 + 2 + 3 = 6CODE SEGMENT ASSUME CS:CODEBEGIN: MOV AL,01H MOV BL,02H ADD AL,BL INC BL ADD AL,BL ADD AL,30H MOV DL,AL MOV AH,02H INT 21H MOV AH,4CH INT 21HCODE ENDS END BEGIN 03.编程实现1+2+3+…+1001234567891011121314151617181920212223;1到100的和DATA SEGMENT SUM DW ?DATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATABEGIN: MOV AX,DATA MOV DS,AX MOV AX,0 MOV BX,1 MOV CX,100SLOOP: ADD AX,BX ADD BX,1 LOOP SLOOP MOV SUM,AX MOV DX,AX MOV AH,4CH INT 21HCODE ENDS END BEGIN 04.100以内的偶数（奇数）求和1234567891011121314151617181920212223;方法一：循环50次求和DATA SEGMENT SUM DW ?DATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATABEGIN: MOV AX,DATA MOV DS,AX MOV AX,0 ; 这里是 0 为偶数求和，是 1 为奇数求和 MOV BX,2 MOV CX,50 ;计数器 CXSLOOP: ADD AX,BX ADD BX,2 LOOP SLOOP ; LOOP 会自动寻找计数器 CX MOV SUM,AX MOV DX,AX MOV AH,4CH INT 21HCODE ENDS END BEGIN 05.100以内的偶数（奇数）求和1234567891011121314151617181920212223;方法二：条件判断求和DATA SEGMENT SUM DW ?DATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATASTART: MOV AX,DATA MOV DS,AX MOV AX,0 ; 这里是 0 为偶数求和，是 1 为奇数求和 MOV BX,2AGAIN: ADD AX,BX ADD BX,2 CMP BX,100 JBE AGAIN MOV DX,AX MOV SUM,AX MOV AH,4CH INT 21HCODE ENDS END START 06.求数组最大（小）值源代码123456789101112131415161718192021222324252627;求数组最大值DATA SEGMENT MAXAY DW ? ARRAY DW 2,6,-3,10,-5,2,12,13,16,-8DATA ENDSCODE SEGMENT ASSUME CS:CODE,DS:DATABEGIN: MOV AX,DATA MOV DS,AX LEA SI,ARRAY MOV CX,10 MOV AX,[SI]MAXCK: ADD SI,2 CMP AX,[SI] JGE NEXT ;最大值用 JGE ，最小值用 JLE MOV AX,[SI]NEXT: LOOP MAXCK MOV MAXAY,AX MOV DX,AX MOV AH,4CH INT 21HCODE ENDS END BEGIN 程序流程图 07.小大写字母转换1234567891011121314151617181920;小大写字母转换 P91 3.16CODE SEGMENT ASSUME CS:CODEBEGIN: MOV AH,01H INT 21H ;从键盘读入 CMP AL,&#x27;a&#x27; JB STOP ;与a比较 CMP AL,&#x27;z&#x27; JA STOP ;与z比较 SUB AL,20H ;转换成大写 MOV DL,AL MOV AH,02H INT 21HSTOP: MOV AH,4CH INT 21HCODE ENDS END BEGIN 对代码有疑问？请点击 https://wj.qq.com/**填写问题汇总问卷，老师将在下周统一解答。 Organized by Amos © 2019 2019/06/05 18:20","categories":[{"name":"知识整理","slug":"知识整理","permalink":"https://blog.amoswu.top/categories/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"name":"笔记","slug":"知识整理/笔记","permalink":"https://blog.amoswu.top/categories/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"2019","slug":"2019","permalink":"https://blog.amoswu.top/tags/2019/"},{"name":"汇编","slug":"汇编","permalink":"https://blog.amoswu.top/tags/%E6%B1%87%E7%BC%96/"},{"name":"微机原理","slug":"微机原理","permalink":"https://blog.amoswu.top/tags/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"},{"name":"Study","slug":"Study","permalink":"https://blog.amoswu.top/tags/Study/"},{"name":"HBTU","slug":"HBTU","permalink":"https://blog.amoswu.top/tags/HBTU/"}]},{"title":"Windows装机相关问题之装机知识扫盲","slug":"Windows装机相关问题","date":"2019-04-26T16:00:00.000Z","updated":"2026-01-30T07:08:14.000Z","comments":true,"path":"e16.html","link":"","permalink":"https://blog.amoswu.top/e16.html","excerpt":"","text":"众所周知，电脑系统崩溃，除了恢复出厂设置之外，就需要重装系统了。重装系统也称之为装机，装机之前就需要做好准备工作，准备工作之一就是先了解下面几个问题。 硬盘分区格式目前主流的电脑硬盘分区格式有两种，一种是GUID（GUID Partition Table，缩写：GPT），另一种是MBR（Main Boot Record）。 定义GUID： 定义1—— A GUID is an acronyom that stands for Globally Unique Identifier, they are also referred to as UUIDs or Universaly Unique Identifiers - there is no real difference between the two. Technically they are 128-bit unique reference numbers used in computing which are highly unlikely to repeat when generated despite there being no central GUID authority to ensure uniqueness. GUID是代表全球唯一标识符的首字母缩略词，它们也被称为UUID或Universaly唯一标识符 - 两者之间没有真正的区别。从技术上讲，它们是计算中使用的128位唯一引用号，尽管没有中央GUID权限来确保唯一性，但它们在生成时极不可能重复。 ——from http://guid.one/guid 定义2—— A universally unique identifier (UUID) is a 128-bit number used to identify information in computer systems. The term globally unique identifier (GUID) is also used, typically in software created by Microsoft. When generated according to the standard methods, UUIDs are for practical purposes unique, without depending for their uniqueness on a central registration authority or coordination between the parties generating them, unlike most other numbering schemes. While the probability that a UUID will be duplicated is not zero, it is close enough to zero to be negligible. 全局唯一标识符（英语：Globally Unique Identifier，缩写：GUID；发音为/ˈɡuːɪd/或/ˈɡwɪd/）是一种由算法生成的唯一标识，通常表示成32个16进制数字（0－9，A－F）组成的字符串，如：{21EC2020-3AEA-1069-A2DD-08002B30309D}，它实质上是一个128位长的二进制整数。GUID一词有时也专指微软对UUID标准的实现。GUID的主要目的是产生完全唯一的数字。在理想情况下，任何计算机和计算机集群都不会生成两个相同的GUID。GUID的总数也足够大，达到了2128（3.4×1038）个，所以随机生成两个相同GUID的可能性是非常小的，但并不为0。所以，用于生成GUID的算法通常都加入了非随机的参数（如时间），以保证这种重复的情况不会发生。 ——from Wikipedia MBR： A master boot record (MBR) is a special type of boot sector at the very beginning of partitioned computer mass storage devices like fixed disks or removable drives intended for use with IBM PC-compatible systems and beyond. The concept of MBRs was publicly introduced in 1983 with PC DOS 2.0. 主引导记录（MBR）是分区计算机大容量存储设备（如固定磁盘或可移动驱动器）的最开始的一种特殊类型的引导扇区，旨在与IBM PC兼容系统一起使用。 MBR的概念于1983年与PC DOS 2.0一起公开发布。 ——from Wikipedia 相关知识MBR MBR不仅是计算机开机后访问硬盘时所必须要读取的首个扇区，还是由分区程序产生的不依赖于任何操作系统的。只有这样才能够实现多系统的引导。 MBR型的硬盘最多只能识别4个主要分区，这是由主引导记录的结构决定的。 在MBR分区表中，一个分区的最大容量为2T 在MBR分区表中最多4个主分区或者3个主分区＋1个扩展分区，也就是说扩展分区只能有一个，然后可以再细分为多个逻辑分区。 GUID GUID是一个实体硬盘的分区结构，是EFI的一部分，用来替代BIOS中的主引导记录分区表。 GPT磁盘分区样式支持最大卷为18 EB（Exabytes）（1EB=1048576TB）并且每磁盘的分区数没有上限，但Windows最大仅支持128个GPT分区 BIOS的两种启动模式目前存在的两种BIOS启动模式分别是：Legacy、UEFI LegacyLegacy BIOS是指传统的 BIOS，用Legacy引导的系统运行流程通常是：开机→BIOS初始化→BIOS自检→引导操作系统→进入系统。而该启动模式对应的硬盘分区格式应该为MBR格式。 UEFI 统一可扩展固件接口（英语：Unified Extensible Firmware Interface，缩写UEFI）是一种个人计算机系统规格，用来定义操作系统与系统固件之间的软件界面，作为BIOS的替代方案。可扩展固件接口负责加电自检（POST）、联系操作系统以及提供连接操作系统与硬件的接口。 ——from Wikipedia 用UEFI引导的系统运行流程通常是：开始→UEFI初始化→引导操作系统→进入系统，则该启动模式对应的硬盘分区格式应该为GUID格式。通俗的说，UEFI是一种新的主板引导初始化的标注设置，具有启动速度快、安全性高和支持大容量硬盘而闻名。 通过对比不难发现，UEFI的启动速度要快于Legacy，原因是省去了BIOS自检。所以，在UEFI出现后，多数pc厂商都选择预装Windows 8 及以上版本的系统，除了Windows 8 及以上版本的系统开机优化要好之外，还因为它们都支持UEFI引导启动，这也是很多Windows 7 PC开机速度慢的一个原因。 小结说了这么多，到底要用哪种方案进行装机呢？在这里，我只说两点忠告。 1.BIOS是新平台 ——&gt; 必选UEFI，特殊要求装Windows7的话选Legacy。所谓新平台就是购买年份在2015年以后，处理器在 Intel 5代或同等处理能力及以上的机型。 2.BIOS是老平台 ——&gt; 想都不要想直接选Legacy，不解释。 另一个需要科普的是，在一般的Windows电脑中，必备的两个分区是ESP分区和MSR分区，不可删除！ 附ESP与MSR分区的相关知识： 一、esp即EFI系统分区1、全称EFI system partition，简写为ESP。msr分区本身没有做任何工作，是名副其实的保留分区。ESP虽然是一个FAT16或FAT32格式的物理分区，但是其分区标识是EF（十六进制）而非常规的OE或OC。因此，该分区在Windows操作系统下一般是不可见的。支持EFI模式的电脑需要从ESP启动系统，E Fl固件可从ESP加载EFI启动程序和应用程序。2、ESP是一个独立于操作系统之外的分区，操作系统被引导之后，就不再依赖它。这使得ESP非常适用来存储那些系统级的维护性的工具和数据，比如：引导管理程序、驱动程序、系统维护工具、系统备份等，甚至可以在ESP里安装一个特殊的操作系统。3、ESP也可以看做是一个安全的隐藏的分区，可以把引导管理程序、系统维护工具、系统恢复工具及镜像等放到ESP，可以自己打造“一键恢复系统”。而且，不仅可以自己进行DIY，还要更方便、更通用。二、msr分区是保留分区1、windows不会向msr分区建立文件系统或者写数据，而是为了调整分区结构而保留的分区。在Wi n8以上系统更新时，会检测msr分区。msr分区本质上就是写在分区表上面的“未分配空间”，目的是微软不想让别人乱动。2、msr分区的用途是防止将一块GPT磁盘接到老系统中，被当作未格式化的空硬盘而继续操作（例如重新格式化）导致数据丢失。GPT磁盘上有了这个分区，当把它接入XP等老系统中，会提示无法识别的磁盘，也无法进一步操作。 ——来自 百度知道 下面一起来看一下日常生活中比较常(Keng)见(Ren)的几个品牌的BIOS。 1.Dell （戴尔）给戴尔电脑重装系统最大的一个坑——BIOS设置。 Win10降到Win7必须打开Legacy，步骤如下： Step 1.关闭安全模式 —— Secure boot -&gt;Secure boot enable 勾选 Disabled Step 2.打开高级启动项 —— Advanced Boot Options 勾选 Enable Legacy Option Roms Step 3.更改启动引导顺序 —— Boot sequence 勾选 Legacy Step 4.保存退出——Apply -&gt; Exit 或 按下 F10 -&gt; Save and exit 2.Lenovo （联想）给联想电脑重装系统的一个小坑——通过还原键进入BIOS。 许多联想系列、ThinkPad系列的笔记本开机出现 Lenovo 图标时不会提示按下哪个键进入BIOS菜单，这是因为联想在主板上加了一个物理按键，这个按键其实是不嫩用手按下去的，因为它很小，就像下图中的一个例子所示，一般这种按键都在机身的一侧并且有可辨别的标识。 操作步骤： 拿一个尖锐的物体，比如卡针或者针，在电脑关机的状态下按住此键3-5s，电脑会自动启动。在屏幕出现 “Lenovo”的瞬间，按下 F2（或F12）不同机型的快捷键不同，详情可百度，或直接查看屏幕左下角或右下角提示。 本次的装机相关知识到此结束，如果你在装机过程中还有其他的问题或者发现了更好的技巧，欢迎你在下方评论区与我交流~","categories":[{"name":"科普","slug":"科普","permalink":"https://blog.amoswu.top/categories/%E7%A7%91%E6%99%AE/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"2019","slug":"2019","permalink":"https://blog.amoswu.top/tags/2019/"},{"name":"Windows","slug":"Windows","permalink":"https://blog.amoswu.top/tags/Windows/"},{"name":"装机","slug":"装机","permalink":"https://blog.amoswu.top/tags/%E8%A3%85%E6%9C%BA/"}]}],"categories":[{"name":"影视评论","slug":"影视评论","permalink":"https://blog.amoswu.top/categories/%E5%BD%B1%E8%A7%86%E8%AF%84%E8%AE%BA/"},{"name":"教程","slug":"教程","permalink":"https://blog.amoswu.top/categories/%E6%95%99%E7%A8%8B/"},{"name":"随笔","slug":"随笔","permalink":"https://blog.amoswu.top/categories/%E9%9A%8F%E7%AC%94/"},{"name":"科普","slug":"科普","permalink":"https://blog.amoswu.top/categories/%E7%A7%91%E6%99%AE/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.amoswu.top/categories/%E7%AC%94%E8%AE%B0/"},{"name":"笔记","slug":"教程/笔记","permalink":"https://blog.amoswu.top/categories/%E6%95%99%E7%A8%8B/%E7%AC%94%E8%AE%B0/"},{"name":"知识整理","slug":"知识整理","permalink":"https://blog.amoswu.top/categories/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"name":"新知","slug":"新知","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/"},{"name":"笔记","slug":"新知/笔记","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/%E7%AC%94%E8%AE%B0/"},{"name":"特别博文","slug":"特别博文","permalink":"https://blog.amoswu.top/categories/%E7%89%B9%E5%88%AB%E5%8D%9A%E6%96%87/"},{"name":"随笔","slug":"新知/随笔","permalink":"https://blog.amoswu.top/categories/%E6%96%B0%E7%9F%A5/%E9%9A%8F%E7%AC%94/"},{"name":"笔记","slug":"知识整理/笔记","permalink":"https://blog.amoswu.top/categories/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"莲花楼","slug":"莲花楼","permalink":"https://blog.amoswu.top/tags/%E8%8E%B2%E8%8A%B1%E6%A5%BC/"},{"name":"剧评","slug":"剧评","permalink":"https://blog.amoswu.top/tags/%E5%89%A7%E8%AF%84/"},{"name":"原创","slug":"原创","permalink":"https://blog.amoswu.top/tags/%E5%8E%9F%E5%88%9B/"},{"name":"教程","slug":"教程","permalink":"https://blog.amoswu.top/tags/%E6%95%99%E7%A8%8B/"},{"name":"2023","slug":"2023","permalink":"https://blog.amoswu.top/tags/2023/"},{"name":"2022","slug":"2022","permalink":"https://blog.amoswu.top/tags/2022/"},{"name":"2021","slug":"2021","permalink":"https://blog.amoswu.top/tags/2021/"},{"name":"随笔","slug":"随笔","permalink":"https://blog.amoswu.top/tags/%E9%9A%8F%E7%AC%94/"},{"name":"Qt","slug":"Qt","permalink":"https://blog.amoswu.top/tags/Qt/"},{"name":"科普","slug":"科普","permalink":"https://blog.amoswu.top/tags/%E7%A7%91%E6%99%AE/"},{"name":"笔记","slug":"笔记","permalink":"https://blog.amoswu.top/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Golang","slug":"Golang","permalink":"https://blog.amoswu.top/tags/Golang/"},{"name":"Markdown","slug":"Markdown","permalink":"https://blog.amoswu.top/tags/Markdown/"},{"name":"2020","slug":"2020","permalink":"https://blog.amoswu.top/tags/2020/"},{"name":"新知识","slug":"新知识","permalink":"https://blog.amoswu.top/tags/%E6%96%B0%E7%9F%A5%E8%AF%86/"},{"name":"转载","slug":"转载","permalink":"https://blog.amoswu.top/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"C++","slug":"C","permalink":"https://blog.amoswu.top/tags/C/"},{"name":"2019","slug":"2019","permalink":"https://blog.amoswu.top/tags/2019/"},{"name":"特别博文","slug":"特别博文","permalink":"https://blog.amoswu.top/tags/%E7%89%B9%E5%88%AB%E5%8D%9A%E6%96%87/"},{"name":"汇编","slug":"汇编","permalink":"https://blog.amoswu.top/tags/%E6%B1%87%E7%BC%96/"},{"name":"微机原理","slug":"微机原理","permalink":"https://blog.amoswu.top/tags/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"},{"name":"Study","slug":"Study","permalink":"https://blog.amoswu.top/tags/Study/"},{"name":"HBTU","slug":"HBTU","permalink":"https://blog.amoswu.top/tags/HBTU/"},{"name":"Windows","slug":"Windows","permalink":"https://blog.amoswu.top/tags/Windows/"},{"name":"装机","slug":"装机","permalink":"https://blog.amoswu.top/tags/%E8%A3%85%E6%9C%BA/"}]}